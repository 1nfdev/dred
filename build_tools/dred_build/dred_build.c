
#define DR_IMPLEMENTATION
#include "../../../dr_libs/dr.h"

#define DR_PATH_IMPLEMENTATION
#include "../../../dr_libs/dr_path.h"

#define GB_STRING_IMPLEMENTATION
#include "../../source/gb_string.h"

#include <stdio.h>
#include <assert.h>

void fwrite_string(FILE* pFile, const char* str)
{
    fwrite(str, 1, strlen(str), pFile);
}

void generate_commands_list(FILE* pFileOut)
{
    assert(pFileOut != NULL);
    
    size_t fileDataSize;
    char* fileData = dr_open_and_read_text_file("../source/dred_commands.h", &fileDataSize);
    if (fileData == NULL) {
        return;
    }

    // Look for the line beginning with "// BEGIN COMMAND LIST"
    char line[1024];
    const char* nextLine = fileData;
    while (nextLine != NULL) {
        if (dr_copy_line(nextLine, line, sizeof(line)) == (size_t)-1) {
            return;
        }
        if (strstr(line, "// BEGIN COMMAND LIST") != NULL) {
            nextLine = dr_next_line(nextLine);
            break;
        }
        nextLine = dr_next_line(nextLine);
    }


    char* CommandNamePool = gb_make_string("const char g_CommandNamePool[] = ");
    char* CommandNames    = gb_make_string("const char* g_CommandNames[] = {\n");
    char* Commands        = gb_make_string("dred_command g_Commands[] = {\n");

    size_t runningNameLength = 0;
    int commandCount = 0;

    while (nextLine != NULL) {
        // The next line should be in the format of <name> <proc> <flags>
        size_t lineLength = dr_copy_line(nextLine, line, sizeof(line));
        if (lineLength <= 2) {
            nextLine = dr_next_line(nextLine);
            continue;
        }

        if (strstr(line, "// END COMMAND LIST") != NULL) {
            break;
        }

        
        char name[256];
        const char* next = dr_next_token(line + 2, name, sizeof(name));     // Skip past "//"
        if (next == NULL) {
            nextLine = dr_next_line(nextLine);
            continue;
        }

        char proc[256];
        next = dr_next_token(next, proc, sizeof(proc));
        if (next == NULL) {
            nextLine = dr_next_line(nextLine);
            continue;
        }

        char flags[256];
        next = dr_next_token(next, flags, sizeof(flags));
        if (next == NULL) {
            nextLine = dr_next_line(nextLine);
            continue;
        }


        snprintf(line, sizeof(line), "\n    \"%s\\0\"", name);
        CommandNamePool = gb_append_cstring(CommandNamePool, line);

        snprintf(line, sizeof(line), "    g_CommandNamePool + %d,\n", (int)runningNameLength);
        CommandNames = gb_append_cstring(CommandNames, line);

        snprintf(line, sizeof(line), "    {%s, %s},\n", proc, flags);
        Commands = gb_append_cstring(Commands, line);

        runningNameLength += strlen(name)+1;
        commandCount += 1;

        nextLine = dr_next_line(nextLine + lineLength);
    }


    CommandNamePool = gb_append_cstring(CommandNamePool, ";\n\n");
    CommandNames    = gb_append_cstring(CommandNames,    "};\n\n");
    Commands        = gb_append_cstring(Commands,        "};\n\n");

    fwrite_string(pFileOut, CommandNamePool);
    fwrite_string(pFileOut, CommandNames);
    fwrite_string(pFileOut, Commands);

    snprintf(line, sizeof(line), "#define DRED_COMMAND_COUNT %d", commandCount);
    fwrite_string(pFileOut, line);
}

int main(int argc, char** argv)
{
    (void)argc;
    (void)argv;

    char exedir[256];
    dr_get_executable_directory_path(exedir, sizeof(exedir));
    dr_set_current_directory(exedir);

    FILE* pFileOut = dr_fopen("../source/dred_autogenerated.c", "w+b");
    if (pFileOut == NULL) {
        printf("Failed to create output file.");
        return -1;
    }

    fwrite_string(pFileOut, "// This file was automatically generated by the pre-build tool. Do not modify.\n\n");


    // Commands.
    generate_commands_list(pFileOut);

    

    return 0;
}