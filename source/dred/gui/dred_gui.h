// Copyright (C) 2016 David Reid. See included LICENSE file.

// QUICK NOTES
//
// General
// - dr_gui is a low-level GUI system that works on generic objects referred to as "elements".
// - An element is the most basic unit in dr_gui. It contains basic information about it's layout and hierarchy.
// - Elements can be used as the building blocks for more complex controls such as list boxes and scrollbars.
// - The layout of elements use floats instead of integers. The rationale for this is that it makes it easier to do certain
//   layout arithmetic. For example, if you want to evenly distribute 3 elements across a fixed area, the integer based
//   arithmetic can cause rounding errors which cause the elements to not sit flush against the area. By using float-based
//   arithmetic we can avoid that particular issue.
//
// Hierarchy
// - An element can have a parent and any number of children. If an element does not have a parent, it is referred to as the
//   top-level element.
// - When an element is deleted, it's children will be deleted as well.
// - Top-level elements do not have siblings.
//
// Event Handling
// - The application must notify dr_gui of application-generated events such as key strokes and mouse movements. These are
//   referred to as inbound events. An event that is generated by dr_gui are referred to as outbound events.
// - Inbound events are used to generate outbound events. For example, a mouse-move inbound event will generate an outbound
//   mouse-move event, and perhaps a mouse leave/enter pair.
// - Outbound events are posted and handled immediately. A call to drgui_post_inbound_event() will not return until all of
//   the outbound events it generates have been handled.
// - Inbound events are not thread safe, however an application is free to post an inbound event from any thread so long as
//   it does it's own synchronization.
// - Inbound events will typically specify the relevant top-level element and let dr_gui do the relevant processing required
//   to generate the appropriate outbound events. For example, the mouse-move event will be specified with respect to the top-
//   level element, but dr_gui will determine the exact child element that the mouse moved on and thus should receive the
//   relevant outbound mouse-move event.
// - There are some special events that are handled differently to normal events. The best example is the paint events. The
//   paint event is only called from drgui_draw().
// - Key press/release events are only ever posted to the element that has the keyboard capture/focus which is set with
//   drgui_capture_keyboard(). Thus, when posting an inbound key event, a top-level element is not required when posting
//   those events. The relevant context is still required, however.
//
// Global Outbound Event Handling
// - At times dr_gui will need to notify the host application in order for certain functionality to work properly. For example.
//   when the mouse is captured it won't work 100% correct unless the host application has a chance to capture the mouse against
//   the container window. Because dr_gui has no notion of a window system it relies on the host application to handle this
//   properly.
// - A global outbound event handler should be implemented for each of the following events:
//   - on_dirty: Called when a region of an element is marked as dirty and needs to be redrawn. The application will want to
//     invalidate the container window to trigger an operating system redraw. Set this with drgui_set_global_on_dirty().
//   - on_capture_mouse: Called when the mouse is captured and gives the application the opportunity to capture the mouse against
//     the container window at the operating system level. Set with drgui_set_global_on_capture_mouse().
//   - on_release_mouse: Called when the mouse is released. The opposite of on_capture_mouse.
//   - on_capture_keyboard: Called when an element is given the keyboard focus and gives the application the opportunity to
//     apply the keyboard focus to the container window. Set with drgui_set_global_on_capture_keyboard().
//   - on_release_keyboard: Called when an element loses the keyboard focus. The opposite of on_capture_keyboard.
//   - on_change_cursor: Called when the current cursor needs to be changed as a result of the mouse moving over a new element.
//
// Layout
// - An element's data structure does not store it's relative position but instead stores it's absolute position. The rationale
//   for this is that storing it as relative complicates absolute positioning calculations because it would need to do a recursive
//   traversal of the element's ancestors.
// - Child elements can be scaled by setting an element's inner scale. The inner scale does not scale the element itself - only
//   it's children.
// - When an element is drawn, everything is scaled by it's inner scale. For example, if the inner scale is 2x and a 100x100 quad
//   is drawn, the quad will be scaled to 200x200. An exception to this rule is fonts, which are never scaled. This 0s because
//   text is always drawn based on the size of the font.
// - Applications should only need to work on unscaled coordinates. That is, an application should never need to worry about
//   manual scaling, except for fonts. When positioning and sizing child elements, they should be done based on unscaled
//   coordinates.
// - Use the inner scale system for DPI awareness.
// - The inner scale is applied recursively. That is, if a top level element has it's inner scale set to 2x and one of it's
//   children has an inner scale of 2x, the actual inner scale of the child element will be 4x.
//
//
// Drawing/Painting
// - Drawing is one of the more complex parts of the GUI because it can be a bit unintuitive regarding exactly when an element
//   is drawn and when a drawing function is allowed to be called.
// - To draw an element, call drgui_draw(). This takes a pointer to the element to draw and the rectangle region that should
//   be redrawn. Any children that fall inside the specified rectangle region will be redrawn as well. You do not want to call
//   drgui_draw() on a parent element and then again on it's children because dr_gui will do that automatically.
// - drgui_draw() does not draw anything directly, but rather calls painting callback routines which is where the actual
//   drawing takes place.
// - Sometimes an application will need to be told when a region of an element is dirty and needs redrawing. An example is
//   event-driven, non real-time applications such as normal desktop applications. To mark an element as dirty, you call the
//   drgui_dirty() function which takes the element that is dirty, and the rectangle region that needs to be redrawn. This
//   does not redraw the element immediately, but instead posts an on_dirty event for the application. Marking regions as dirty
//   is not strictly required, but you should prefer it for event-driven applications that require painting operations to be
//   performed at specific times (such as inside Win32's WM_PAINT messages).
// - Some operations will cause a region of an element to become dirty - such as when it is resized. dr_gui will
//   automatically mark the relevant regions as dirty which in turn will cause a paint message to be posted. If this is not
//   required, it can be disabled with drgui_disable_auto_dirty(). You may want to disable automatic dirtying if you are
//   running a real-time application like a game which would redraw the entire GUI every frame anyway and thus not require
//   handling of the paint message.
// - Real-time application guidelines (games, etc.):
//   - drgui_disable_auto_dirty()
//   - drgui_draw(pTopLevelElement, 0, 0, viewportWidth, viewportHeight) at the end of every frame after your main loop.
//


//
// OPTIONS
//
// #define DRGUI_NO_DR_2D
//   Disable dr_2d integration. Disabling dr_2d will require you to implement your own drawing callbacks.
//
// #define DRGUI_NO_TEXT_EDITING
//   Disables the text box control and text engine.


//
// EXAMPLES
//
// Basic Drawing:
//
// drgui_draw(pTopLevelElement, 0, 0, drgui_get_width(pTopLevelElement), drgui_get_height(pTopLevelElement));
//
// -------------------------
//
// Event-Driven Drawing (Win32):
//
// void my_global_on_dirty_win32(drgui_element* pElement, drgui_rect relativeRect) {
//     drgui_rect absoluteRect = relativeRect;
//     drgui_make_rect_absolute(pElement, &absoluteRect);
//
//     RECT rect;
//     rect.left   = absoluteRect.left;
//     rect.top    = absoluteRect.top;
//     rect.right  = absoluteRect.right;
//     rect.height = absoluteRect.bottom;
//     InvalidateRect((HWND)drgui_get_user_data(drgui_find_top_level_element(pElement)), &rect, FALSE);
// }
//
// ...
//
// LRESULT CALLBACK MyWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
//     ...
//     drgui_element* pTopLevelElement = (drgui_element*)GetWindowLongPtr(hWnd, 0);
//     if (pTopLevelElement != NULL) {
//         switch (msg) {
//             ...
//             case WM_PAINT:
//             {
//                 RECT rect;
//                 if (GetUpdateRect(hWnd, &rect, FALSE)) {
//                     drgui_draw(pTopLevelElement, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
//                 }
//
//                 break;
//             }
//             ...
//         }
//     }
//     ...
// }
//

#ifndef DRED_MAX_FONT_FAMILY_LENGTH
#define DRED_MAX_FONT_FAMILY_LENGTH  128
#endif


typedef struct drgui_context drgui_context;
typedef struct drgui_element drgui_element;
typedef struct drgui_color drgui_color;
typedef struct drgui_rect drgui_rect;
typedef struct drgui_painting_callbacks drgui_painting_callbacks;
typedef struct drgui_font drgui_font;
typedef struct drgui_image drgui_image;
typedef struct drgui_font_metrics drgui_font_metrics;
typedef struct drgui_glyph_metrics drgui_glyph_metrics;

typedef unsigned char drgui_byte;
typedef unsigned int drgui_key;

typedef void* drgui_resource;

/// Common system cursors.
typedef enum
{
    drgui_cursor_none,
    drgui_cursor_default,
    drgui_cursor_arrow = drgui_cursor_default,
    drgui_cursor_text,
    drgui_cursor_cross,
    drgui_cursor_size_ns,           // North/South resize arrows.
    drgui_cursor_size_we,           // West/East resize arrows.
    drgui_cursor_size_nesw,         // North/East, South/West resize arrows.
    drgui_cursor_size_nwse          // North/West, South/East resize arrows.
} drgui_cursor_type;

/// Font weights.
typedef enum
{
    drgui_font_weight_medium,
    drgui_font_weight_thin,
    drgui_font_weight_extra_light,
    drgui_font_weight_light,
    drgui_font_weight_semi_light,
    drgui_font_weight_book,
    drgui_font_weight_semi_bold,
    drgui_font_weight_bold,
    drgui_font_weight_extra_bold,
    drgui_font_weight_heavy,
    drgui_font_weight_extra_heavy,

    drgui_font_weight_normal  = drgui_font_weight_medium,
    drgui_font_weight_default = drgui_font_weight_medium

} drgui_font_weight;

/// Font slants.
typedef enum
{
    drgui_font_slant_none,
    drgui_font_slant_italic,
    drgui_font_slant_oblique

} drgui_font_slant;

/// Image formats.
typedef enum
{
    drgui_image_format_rgba8,
    drgui_image_format_bgra8,
    drgui_image_format_argb8,
} drgui_image_format;


/// Font metrics.
struct drgui_font_metrics
{
    int ascent;
    int descent;
    int lineHeight;
    int spaceWidth;
};

/// Glyph metrics.
struct drgui_glyph_metrics
{
    int width;
    int height;
    int originX;
    int originY;
    int advanceX;
    int advanceY;
};


/// Structure representing an RGBA color. Color components are specified in the range of 0 - 255.
struct drgui_color
{
    drgui_byte r;
    drgui_byte g;
    drgui_byte b;
    drgui_byte a;
};

/// Structure representing a rectangle.
struct drgui_rect
{
    float left;
    float top;
    float right;
    float bottom;
};


#define DRGUI_IMAGE_DRAW_BACKGROUND     (1 << 0)
#define DRGUI_IMAGE_HINT_NO_ALPHA       (1 << 1)
#define DRGUI_IMAGE_DRAW_BOUNDS         (1 << 2)
#define DRGUI_IMAGE_CLIP_BOUNDS         (1 << 3)        //< Clips the image to the bounds
#define DRGUI_IMAGE_ALIGN_CENTER        (1 << 4)

#define DRGUI_READ                      (1 << 0)
#define DRGUI_WRITE                     (1 << 1)

#define DRGUI_FONT_NO_CLEARTYPE         (1 << 0)

typedef struct
{
    /// The destination position on the x axis. This is ignored if the DR2D_IMAGE_ALIGN_CENTER option is set.
    float dstX;

    /// The destination position on the y axis. This is ignored if the DR2D_IMAGE_ALIGN_CENTER option is set.
    float dstY;

    /// The destination width.
    float dstWidth;

    /// The destination height.
    float dstHeight;


    /// The source offset on the x axis.
    float srcX;

    /// The source offset on the y axis.
    float srcY;

    /// The source width.
    float srcWidth;

    /// The source height.
    float srcHeight;


    /// The position of the destination's bounds on the x axis.
    float dstBoundsX;

    /// The position of the destination's bounds on the y axis.
    float dstBoundsY;

    /// The width of the destination's bounds.
    float dstBoundsWidth;

    /// The height of the destination's bounds.
    float dstBoundsHeight;


    /// The foreground tint color. This is not applied to the background color, and the alpha component is ignored.
    drgui_color foregroundTint;

    /// The background color. Only used if the DR2D_IMAGE_DRAW_BACKGROUND option is set.
    drgui_color backgroundColor;

    /// The bounds color. This color is used for the region of the bounds that sit on the outside of the destination rectangle. This will
    /// usually be set to the same value as backgroundColor, but it could also be used to draw a border around the image.
    drgui_color boundsColor;


    /// Flags for controlling how the image should be drawn.
    unsigned int options;

} drgui_draw_image_args;


typedef void (* drgui_callback)();

typedef void (* drgui_on_move_proc)                 (drgui_element* pElement, float newRelativePosX, float newRelativePosY);
typedef void (* drgui_on_size_proc)                 (drgui_element* pElement, float newWidth, float newHeight);
typedef void (* drgui_on_mouse_enter_proc)          (drgui_element* pElement);
typedef void (* drgui_on_mouse_leave_proc)          (drgui_element* pElement);
typedef void (* drgui_on_mouse_move_proc)           (drgui_element* pElement, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* drgui_on_mouse_button_down_proc)    (drgui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* drgui_on_mouse_button_up_proc)      (drgui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* drgui_on_mouse_button_dblclick_proc)(drgui_element* pElement, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* drgui_on_mouse_wheel_proc)          (drgui_element* pElement, int delta, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* drgui_on_key_down_proc)             (drgui_element* pElement, drgui_key key, int stateFlags);
typedef void (* drgui_on_key_up_proc)               (drgui_element* pElement, drgui_key key, int stateFlags);
typedef void (* drgui_on_printable_key_down_proc)   (drgui_element* pElement, unsigned int character, int stateFlags);
typedef void (* drgui_on_paint_proc)                (drgui_element* pElement, drgui_rect relativeRect, void* pPaintData);
typedef void (* drgui_on_dirty_proc)                (drgui_element* pElement, drgui_rect relativeRect);
typedef bool (* drgui_on_hittest_proc)              (drgui_element* pElement, float relativePosX, float relativePosY);
typedef void (* drgui_on_capture_mouse_proc)        (drgui_element* pElement);
typedef void (* drgui_on_release_mouse_proc)        (drgui_element* pElement);
typedef void (* drgui_on_capture_keyboard_proc)     (drgui_element* pElement, drgui_element* pPrevCapturedElement);
typedef void (* drgui_on_release_keyboard_proc)     (drgui_element* pElement, drgui_element* pNewCapturedElement);
typedef void (* drgui_on_change_cursor_proc)        (drgui_element* pElement, drgui_cursor_type cursor);
typedef void (* drgui_on_delete_element_proc)       (drgui_element* pElement);
typedef void (* drgui_on_log)                       (drgui_context* pContext, const char* message);

typedef void (* drgui_draw_begin_proc)                   (void* pPaintData);
typedef void (* drgui_draw_end_proc)                     (void* pPaintData);
typedef void (* drgui_set_clip_proc)                     (drgui_rect relativeRect, void* pPaintData);
typedef void (* drgui_get_clip_proc)                     (drgui_rect* pRectOut, void* pPaintData);
typedef void (* drgui_draw_line_proc)                    (float startX, float startY, float endX, float endY, float width, drgui_color color, void* pPaintData);
typedef void (* drgui_draw_rect_proc)                    (drgui_rect relativeRect, drgui_color color, void* pPaintData);
typedef void (* drgui_draw_rect_outline_proc)            (drgui_rect relativeRect, drgui_color color, float outlineWidth, void* pPaintData);
typedef void (* drgui_draw_rect_with_outline_proc)       (drgui_rect relativeRect, drgui_color color, float outlineWidth, drgui_color outlineColor, void* pPaintData);
typedef void (* drgui_draw_round_rect_proc)              (drgui_rect relativeRect, drgui_color color, float radius, void* pPaintData);
typedef void (* drgui_draw_round_rect_outline_proc)      (drgui_rect relativeRect, drgui_color color, float radius, float outlineWidth, void* pPaintData);
typedef void (* drgui_draw_round_rect_with_outline_proc) (drgui_rect relativeRect, drgui_color color, float radius, float outlineWidth, drgui_color outlineColor, void* pPaintData);
typedef void (* drgui_draw_text_proc)                    (drgui_resource font, const char* text, int textLengthInBytes, float posX, float posY, drgui_color color, drgui_color backgroundColor, void* pPaintData);
typedef void (* drgui_draw_image_proc)                   (drgui_resource image, drgui_draw_image_args* pArgs, void* pPaintData);

typedef drgui_resource (* drgui_create_font_proc)                        (void* pPaintingContext, const char* family, unsigned int size, drgui_font_weight weight, drgui_font_slant slant, float rotation, unsigned int flags);
typedef void           (* drgui_delete_font_proc)                        (drgui_resource font);
typedef unsigned int   (* drgui_get_font_size_proc)                      (drgui_resource font);
typedef bool           (* drgui_get_font_metrics_proc)                   (drgui_resource font, drgui_font_metrics* pMetricsOut);
typedef bool           (* drgui_get_glyph_metrics_proc)                  (drgui_resource font, unsigned int utf32, drgui_glyph_metrics* pMetricsOut);
typedef bool           (* drgui_measure_string_proc)                     (drgui_resource font, const char* text, size_t textSizeInBytes, float* pWidthOut, float* pHeightOut);
typedef bool           (* drgui_get_text_cursor_position_from_point_proc)(drgui_resource font, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float* pTextCursorPosXOut, size_t* pCharacterIndexOut);
typedef bool           (* drgui_get_text_cursor_position_from_char_proc) (drgui_resource font, const char* text, size_t characterIndex, float* pTextCursorPosXOut);

typedef drgui_resource     (* drgui_create_image_proc)            (void* pPaintingContext, unsigned int width, unsigned int height, drgui_image_format format, unsigned int stride, const void* pImageData);
typedef void               (* drgui_delete_image_proc)            (drgui_resource image);
typedef drgui_image_format (* drgui_get_optimal_image_format_proc)(void* pPaintingContext);
typedef void               (* drgui_get_image_size_proc)          (drgui_resource image, unsigned int* pWidthOut, unsigned int* pHeightOut);
typedef void*              (* drgui_map_image_data_proc)          (drgui_resource image, unsigned int accessFlags);
typedef void               (* drgui_unmap_image_data_proc)        (drgui_resource image);

typedef bool (* drgui_visible_iteration_proc)(drgui_element* pElement, drgui_rect *pRelativeRect, void* pUserData);


// Key state flags.
#define DRGUI_MOUSE_BUTTON_LEFT_DOWN   (1 << 0)
#define DRGUI_MOUSE_BUTTON_RIGHT_DOWN  (1 << 1)
#define DRGUI_MOUSE_BUTTON_MIDDLE_DOWN (1 << 2)
#define DRGUI_MOUSE_BUTTON_4_DOWN      (1 << 3)
#define DRGUI_MOUSE_BUTTON_5_DOWN      (1 << 4)
#define DRGUI_KEY_STATE_SHIFT_DOWN     (1 << 5)        // Whether or not a shift key is down at the time the input event is handled.
#define DRGUI_KEY_STATE_CTRL_DOWN      (1 << 6)        // Whether or not a ctrl key is down at the time the input event is handled.
#define DRGUI_KEY_STATE_ALT_DOWN       (1 << 7)        // Whether or not an alt key is down at the time the input event is handled.
#define DRGUI_KEY_STATE_AUTO_REPEATED  (1 << 31)       // Whether or not the key press is generated due to auto-repeating. Only used with key down events.

// Common mouse buttons.
#define DRGUI_MOUSE_BUTTON_LEFT      1
#define DRGUI_MOUSE_BUTTON_RIGHT     2
#define DRGUI_MOUSE_BUTTON_MIDDLE    3

// Common key codes.
#define DRGUI_BACKSPACE              0xff08
#define DRGUI_SHIFT                  0xff10
#define DRGUI_ESCAPE                 0xff1b
#define DRGUI_PAGE_UP                0xff55
#define DRGUI_PAGE_DOWN              0xff56
#define DRGUI_END                    0xff57
#define DRGUI_HOME                   0xff50
#define DRGUI_ARROW_LEFT             0x8fb
#define DRGUI_ARROW_UP               0x8fc
#define DRGUI_ARROW_RIGHT            0x8fd
#define DRGUI_ARROW_DOWN             0x8fe
#define DRGUI_DELETE                 0xffff
#define DRGUI_F1                     0xffbe
#define DRGUI_F2                     0xffbf
#define DRGUI_F3                     0xffc0
#define DRGUI_F4                     0xffc1
#define DRGUI_F5                     0xffc2
#define DRGUI_F6                     0xffc3
#define DRGUI_F7                     0xffc4
#define DRGUI_F8                     0xffc5
#define DRGUI_F9                     0xffc6
#define DRGUI_F10                    0xffc7
#define DRGUI_F11                    0xffc8
#define DRGUI_F12                    0xffc9

static size_t drgui_strcpy(char* dst, size_t dstSize, const char* src)
{
    if (strcpy_s(dst, dstSize, src) == 0) {
        return strlen(dst);
    }

    return 0;
}

static inline size_t drgui_key_to_string(drgui_key key, char* strOut, size_t strOutSize)
{
    if (strOut == NULL || strOutSize == 0) {
        return 0;
    }

    if (strOutSize == 1) {
        strOut[0] = '\0';
        return 0;
    }


    switch (key)
    {
    case DRGUI_BACKSPACE:   return drgui_strcpy(strOut, strOutSize, "Backspace");
    case DRGUI_SHIFT:       return drgui_strcpy(strOut, strOutSize, "Shift");
    case DRGUI_ESCAPE:      return drgui_strcpy(strOut, strOutSize, "Escape");
    case DRGUI_PAGE_UP:     return drgui_strcpy(strOut, strOutSize, "Page Up");
    case DRGUI_PAGE_DOWN:   return drgui_strcpy(strOut, strOutSize, "Page Down");
    case DRGUI_END:         return drgui_strcpy(strOut, strOutSize, "End");
    case DRGUI_HOME:        return drgui_strcpy(strOut, strOutSize, "Home");
    case DRGUI_ARROW_LEFT:  return drgui_strcpy(strOut, strOutSize, "Arrow Left");
    case DRGUI_ARROW_UP:    return drgui_strcpy(strOut, strOutSize, "Arrow Up");
    case DRGUI_ARROW_RIGHT: return drgui_strcpy(strOut, strOutSize, "Arrow Right");
    case DRGUI_ARROW_DOWN:  return drgui_strcpy(strOut, strOutSize, "Arrow Down");
    case DRGUI_DELETE:      return drgui_strcpy(strOut, strOutSize, "Delete");
    case DRGUI_F1:          return drgui_strcpy(strOut, strOutSize, "F1");
    case DRGUI_F2:          return drgui_strcpy(strOut, strOutSize, "F2");
    case DRGUI_F3:          return drgui_strcpy(strOut, strOutSize, "F3");
    case DRGUI_F4:          return drgui_strcpy(strOut, strOutSize, "F4");
    case DRGUI_F5:          return drgui_strcpy(strOut, strOutSize, "F5");
    case DRGUI_F6:          return drgui_strcpy(strOut, strOutSize, "F6");
    case DRGUI_F7:          return drgui_strcpy(strOut, strOutSize, "F7");
    case DRGUI_F8:          return drgui_strcpy(strOut, strOutSize, "F8");
    case DRGUI_F9:          return drgui_strcpy(strOut, strOutSize, "F9");
    case DRGUI_F10:         return drgui_strcpy(strOut, strOutSize, "F10");
    case DRGUI_F11:         return drgui_strcpy(strOut, strOutSize, "F11");
    case DRGUI_F12:         return drgui_strcpy(strOut, strOutSize, "F12");
    }

    if (key >= 32 && key <= 126) {
        strOut[0] = (char)key;
        strOut[1] = '\0';
        return 1;
    }

    // TODO: Non-ascii characters.
    return 0;
}

drgui_key drgui_key_parse(const char* str)
{
    if (str == NULL || str[0] == '\0') {
        return 0;
    }

    if (_stricmp(str, "backspace")   == 0) return DRGUI_BACKSPACE;
    if (_stricmp(str, "shift")       == 0) return DRGUI_SHIFT;
    if (_stricmp(str, "escape")      == 0) return DRGUI_ESCAPE;
    if (_stricmp(str, "page up")     == 0 || _stricmp(str, "pageup")     == 0) return DRGUI_PAGE_UP;
    if (_stricmp(str, "page down")   == 0 || _stricmp(str, "pagedown")   == 0) return DRGUI_PAGE_DOWN;
    if (_stricmp(str, "end")         == 0) return DRGUI_END;
    if (_stricmp(str, "home")        == 0) return DRGUI_HOME;
    if (_stricmp(str, "arrow left")  == 0 || _stricmp(str, "arrowleft")  == 0) return DRGUI_ARROW_LEFT;
    if (_stricmp(str, "arrow up")    == 0 || _stricmp(str, "arrowup")    == 0) return DRGUI_ARROW_UP;
    if (_stricmp(str, "arrow right") == 0 || _stricmp(str, "arrowright") == 0) return DRGUI_ARROW_RIGHT;
    if (_stricmp(str, "arrow down")  == 0 || _stricmp(str, "arrowdown")  == 0) return DRGUI_ARROW_DOWN;
    if (_stricmp(str, "delete")      == 0) return DRGUI_BACKSPACE;

    if (str[0] == 'F' || str[0] == 'f') {
        if (str[1] ==  '1') {
            if (str[2] == '\0') {
                return DRGUI_F1;
            } else {
                if (str[2] == '0' && str[2] == '\0') return DRGUI_F10;
                if (str[2] == '1' && str[2] == '\0') return DRGUI_F11;
                if (str[2] == '2' && str[2] == '\0') return DRGUI_F12;
            }
        }
        if (str[1] == '2' && str[2] == '\0') return DRGUI_F2;
        if (str[1] == '3' && str[2] == '\0') return DRGUI_F3;
        if (str[1] == '4' && str[2] == '\0') return DRGUI_F4;
        if (str[1] == '5' && str[2] == '\0') return DRGUI_F5;
        if (str[1] == '6' && str[2] == '\0') return DRGUI_F6;
        if (str[1] == '7' && str[2] == '\0') return DRGUI_F7;
        if (str[1] == '8' && str[2] == '\0') return DRGUI_F8;
        if (str[1] == '9' && str[2] == '\0') return DRGUI_F9;
    }


    // ASCII characters.
    if (str[0] >= 32 && str[0] <= 126 && str[1] == '\0') {
        return str[0];
    }

    if (_stricmp(str, "tab") == 0) {
        return '\t';
    }


    // TODO: Non-ascii characters.
    return 0;
}


/// Structure containing callbacks for painting routines.
struct drgui_painting_callbacks
{
    drgui_draw_begin_proc                          drawBegin;
    drgui_draw_end_proc                            drawEnd;

    drgui_set_clip_proc                            setClip;
    drgui_get_clip_proc                            getClip;

    drgui_draw_line_proc                           drawLine;
    drgui_draw_rect_proc                           drawRect;
    drgui_draw_rect_outline_proc                   drawRectOutline;
    drgui_draw_rect_with_outline_proc              drawRectWithOutline;
    drgui_draw_round_rect_proc                     drawRoundRect;
    drgui_draw_round_rect_outline_proc             drawRoundRectOutline;
    drgui_draw_round_rect_with_outline_proc        drawRoundRectWithOutline;
    drgui_draw_text_proc                           drawText;
    drgui_draw_image_proc                          drawImage;

    drgui_create_font_proc                         createFont;
    drgui_delete_font_proc                         deleteFont;
    drgui_get_font_size_proc                       getFontSize;
    drgui_get_font_metrics_proc                    getFontMetrics;
    drgui_get_glyph_metrics_proc                   getGlyphMetrics;
    drgui_measure_string_proc                      measureString;
    drgui_get_text_cursor_position_from_point_proc getTextCursorPositionFromPoint;
    drgui_get_text_cursor_position_from_char_proc  getTextCursorPositionFromChar;

    drgui_create_image_proc                        createImage;
    drgui_delete_image_proc                        deleteImage;
    drgui_get_optimal_image_format_proc            getOptimalImageFormat;
    drgui_get_image_size_proc                      getImageSize;
    drgui_map_image_data_proc                      mapImageData;
    drgui_unmap_image_data_proc                    unmapImageData;
};

struct drgui_image
{
    /// A pointer to the context that owns this image.
    drgui_context* pContext;

    /// The resource handle that is passed around to the callback functions.
    drgui_resource hResource;
};

struct drgui_font
{
    /// A pointer to the context that owns this font.
    drgui_context* pContext;

    /// The font family.
    char family[DRED_MAX_FONT_FAMILY_LENGTH];

    /// The base size of the font. This is set to the value that was used to create the font in the first place.
    unsigned int size;

    /// The font's weight.
    drgui_font_weight weight;

    /// The fon't slant.
    drgui_font_slant slant;

    /// The fon't rotation.
    float rotation;

    /// The font's flags. Can be a combination of the following:
    ///   DRGUI_FONT_NO_CLEARTYPE
    unsigned int flags;

    /// The internal font. This is created by the rendering backend.
    drgui_resource internalFont;
};


struct drgui_element
{
    /// A pointer to the context that owns this element. This should never be null for valid elements.
    drgui_context* pContext;


    /// A pointer to the parent element. This can be null in which case this element is the parent.
    drgui_element* pParent;

    /// A pointer to the first child element.
    drgui_element* pFirstChild;

    /// A pointer to the last child element.
    drgui_element* pLastChild;

    /// A pointer to the next sibling element.
    drgui_element* pNextSibling;

    /// A pointer ot the previous sibing element.
    drgui_element* pPrevSibling;


    /// A pointer to the next dead element. When an element is deleted during an event handler it is not deleted straight away but
    /// rather at the end of the current batch of event processing. Dead elements are stored in a linked list, with this pointer
    /// acting as the link between items. This will be null if the element is the last in the list, or is not marked as dead. Note
    /// that this should not be used to check if the element is marked as dead - use the IS_ELEMENT_DEAD flag instead.
    drgui_element* pNextDeadElement;


    /// The type of the element, as a string. This is only every used by the host application, and is intended to be used as way
    /// to selectively perform certain operations on specific types of GUI elements.
    char type[64];


    /// The absolute position of the element on the x axis. A position of 0 is the left side of the surface it is attached to.
    float absolutePosX;

    /// The absolute position of the element on the y axis. A position of 0 is the top of the surface it is attached to.
    float absolutePosY;

    /// The width of the element.
    float width;

    /// The height of the element.
    float height;


    /// The cursor. Defaults to drge_cursor_default.
    drgui_cursor_type cursor;

    /// Boolean flags.
    unsigned int flags;

    // The region of the element that's dirty.
    drgui_rect dirtyRect;


    /// The function to call when the element's relative position moves.
    drgui_on_move_proc onMove;

    /// The function to call when the element's size changes.
    drgui_on_size_proc onSize;

    /// The function to call when the mouse enters the given element.
    drgui_on_mouse_enter_proc onMouseEnter;

    /// The function to call when the mouse leaves the given element.
    drgui_on_mouse_leave_proc onMouseLeave;

    /// The function to call when the mouse is moved while over the element.
    drgui_on_mouse_move_proc onMouseMove;

    /// The function to call when a mouse buttonis pressed while over the element.
    drgui_on_mouse_button_down_proc onMouseButtonDown;

    /// The function to call when a mouse button is released while over the element.
    drgui_on_mouse_button_up_proc onMouseButtonUp;

    /// The function to call when a mouse button is double-clicked while over the element.
    drgui_on_mouse_button_dblclick_proc onMouseButtonDblClick;

    /// The function to call when the mouse wheel it turned while over the element.
    drgui_on_mouse_wheel_proc onMouseWheel;

    /// The function to call when a key on the keyboard is pressed or auto-repeated.
    drgui_on_key_down_proc onKeyDown;

    /// The function to call when a key on the keyboard is released.
    drgui_on_key_up_proc onKeyUp;

    /// The function to call when a printable character is pressed or auto-repeated. This would be used for text editing.
    drgui_on_printable_key_down_proc onPrintableKeyDown;

    /// The function to call when the paint event is received.
    drgui_on_paint_proc onPaint;

    /// The function to call when the element is marked as dirty.
    drgui_on_dirty_proc onDirty;

    /// The function to call when a hit test needs to be performed.
    drgui_on_hittest_proc onHitTest;

    /// The event handler to call when an element receives the mouse focus.
    drgui_on_capture_mouse_proc onCaptureMouse;

    /// The event handler to call when an element loses the mouse focus.
    drgui_on_release_mouse_proc onReleaseMouse;

    /// The event handler to call when an element receives the keyboard focus.
    drgui_on_capture_keyboard_proc onCaptureKeyboard;

    /// The event handler to call when an element loses the keyboard focus.
    drgui_on_release_keyboard_proc onReleaseKeyboard;


    /// The size of the extra data.
    size_t extraDataSize;

    /// A pointer to the extra data.
    drgui_byte pExtraData[1];
};

struct drgui_context
{
    /// The paiting context.
    void* pPaintingContext;

    /// The painting callbacks.
    drgui_painting_callbacks paintingCallbacks;


    /// The inbound event counter. This is incremented with drgui_begin_inbound_event() and decremented with
    /// drgui_end_inbound_event(). We use this to determine whether or not an inbound event is being processed.
    int inboundEventCounter;

    /// The outbound event counter that we use as the "lock" for outbound events. All outbound events are posted from
    /// inbound events, and all inbound events are already synchronized so we don't need to use a mutex. This is mainly
    /// used as a way to check for erroneous outbound event generation.
    int outboundEventLockCounter;

    /// A pointer to the first element that has been marked as dead. Elements marked as dead are stored as a linked list.
    drgui_element* pFirstDeadElement;

    /// A pointer to the element that is sitting directly under the mouse. This is updated on every inbound mouse move event
    /// and is used for determining when a mouse enter/leave event needs to be posted.
    drgui_element* pElementUnderMouse;

    /// A pointer to the element with the mouse capture.
    drgui_element* pElementWithMouseCapture;

    /// A pointer to the element with the keyboard focus.
    drgui_element* pElementWithKeyboardCapture;

    /// A pointer to the element that wants the keyboard focus. If for some reason an element isn't able to immediately
    /// capture the keyboard (such as while in the middle of a release_keyboard event handler) this will be set to that
    /// particular element. This will then be used to capture the keyboard at a later time when it is able.
    drgui_element* pElementWantingKeyboardCapture;

    /// The current cursor.
    drgui_cursor_type currentCursor;

    /// Boolean flags.
    unsigned int flags;


    /// The global event callback to call when an element is marked as dirty.
    drgui_on_dirty_proc onGlobalDirty;

    /// The global event handler to call when an element captures the mouse.
    drgui_on_capture_mouse_proc onGlobalCaptureMouse;

    /// The global event handler to call when an element releases the mouse.
    drgui_on_release_mouse_proc onGlobalReleaseMouse;

    /// The global event handler to call when an element captures the keyboard.
    drgui_on_capture_keyboard_proc onGlobalCaptureKeyboard;

    /// The global event handler to call when an element releases the keyboard.
    drgui_on_release_keyboard_proc onGlobalReleaseKeyboard;

    /// The global event handler to call when the system cursor needs to change.
    drgui_on_change_cursor_proc onChangeCursor;

    /// The function to call when an element is deleted.
    drgui_on_delete_element_proc onDeleteElement;


    /// The function to call when a log message is posted.
    drgui_on_log onLog;



    /// A pointer to the top level element that was passed in from the last inbound mouse move event.
    drgui_element* pLastMouseMoveTopLevelElement;

    /// The position of the mouse that was passed in from the last inbound mouse move event.
    float lastMouseMovePosX;
    float lastMouseMovePosY;


    // A pointer to the list of dirty elements.
    drgui_element** ppDirtyElements;

    // The size of the buffer containing the dirty elements.
    size_t dirtyElementBufferSize;

    // The number of dirty top-level elements.
    size_t dirtyElementCount;

    /// The counter to use when determining whether or not an on_dirty event needs to be posted. This is incremented with
    /// drgui_begin_auto_dirty() and decremented with drgui_end_auto_dirty(). When the counter is decremented and hits
    /// zero, the on_dirty event will be posted.
    unsigned int dirtyCounter;
};



/////////////////////////////////////////////////////////////////
//
// CORE API
//
/////////////////////////////////////////////////////////////////

/// Creates a context.
drgui_context* drgui_create_context();

/// Deletes a context and everything that it created.
void drgui_delete_context(drgui_context* pContext);



/////////////////////////////////////////////////////////////////
// Events

/// Posts a mouse leave inbound event.
///
/// @remarks
///     The intention behind this event is to allow the application to let dr_gui know that the mouse have left the window. Since dr_gui does
///     not have any notion of a window it must rely on the host application to notify it.
void drgui_post_inbound_event_mouse_leave(drgui_element* pTopLevelElement);

/// Posts a mouse move inbound event.
void drgui_post_inbound_event_mouse_move(drgui_element* pTopLevelElement, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse button down inbound event.
void drgui_post_inbound_event_mouse_button_down(drgui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse button up inbound event.
void drgui_post_inbound_event_mouse_button_up(drgui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse button double-clicked inbound event.
void drgui_post_inbound_event_mouse_button_dblclick(drgui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse wheel inbound event.
void drgui_post_inbound_event_mouse_wheel(drgui_element* pTopLevelElement, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a key down inbound event.
void drgui_post_inbound_event_key_down(drgui_context* pContext, drgui_key key, int stateFlags);

/// Posts a key up inbound event.
void drgui_post_inbound_event_key_up(drgui_context* pContext, drgui_key key, int stateFlags);

/// Posts a printable key down inbound event.
///
/// @remarks
///     The \c character argument should be a UTF-32 code point.
void drgui_post_inbound_event_printable_key_down(drgui_context* pContext, unsigned int character, int stateFlags);


/// Registers the global on_dirty event callback.
///
/// @remarks
///     This is called whenever a region of an element is marked as dirty and allows an application to mark the region of the
///     container window as dirty to trigger an operating system level repaint of the window.
void drgui_set_global_on_dirty(drgui_context* pContext, drgui_on_dirty_proc onDirty);

/// Registers the global on_capture_mouse event callback.
///
/// @remarks
///     This is called whenever an element receives an the mouse capture and allows an application to do operating system level
///     mouse captures against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void drgui_set_global_on_capture_mouse(drgui_context* pContext, drgui_on_capture_mouse_proc onCaptureMouse);

/// Registers the global on_release_mouse event callback.
///
/// @remarks
///     This is called whenever an element loses an the mouse capture and allows an application to do operating system level
///     mouse releases against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void drgui_set_global_on_release_mouse(drgui_context* pContext, drgui_on_release_mouse_proc onReleaseMouse);

/// Registers the global on_capture_keyboard event callback.
///
/// @remarks
///     This is called whenever an element receives an the keyboard capture and allows an application to do an operating system level
///     keyboard focus against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void drgui_set_global_on_capture_keyboard(drgui_context* pContext, drgui_on_capture_keyboard_proc onCaptureKeyboard);

/// Registers the global on_release_keyboard event callback.
///
/// @remarks
///     This is called whenever an element loses an the keyboard capture and allows an application to do an operating system level
///     keyboard release against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void drgui_set_global_on_release_keyboard(drgui_context* pContext, drgui_on_capture_keyboard_proc onReleaseKeyboard);

/// Sets the global on_change_cursor event callback.
///
/// @remarks
///     This is called whenever the operating system needs to change the cursor.
void drgui_set_global_on_change_cursor(drgui_context* pContext, drgui_on_change_cursor_proc onChangeCursor);

/// Sets the function to call when an element is deleted.
void drgui_set_on_delete_element(drgui_context* pContext, drgui_on_delete_element_proc onDeleteElement);


/// Registers the callback to call when a log message is posted.
void drgui_set_on_log(drgui_context* pContext, drgui_on_log onLog);




/////////////////////////////////////////////////////////////////
// Elements

/// Creates an element.
drgui_element* drgui_create_element(drgui_context* pContext, drgui_element* pParent, size_t extraDataSize, const void* pExtraData);

/// Deletes and element.
void drgui_delete_element(drgui_element* pElement);


/// Retrieves the size of the extra data of the given element, in bytes.
size_t drgui_get_extra_data_size(drgui_element* pElement);

/// Retrieves a pointer to the extra data of the given element.
void* drgui_get_extra_data(drgui_element* pElement);


/// Sets the type of the element.
///
/// The type name cannot be more than 63 characters in length.
bool drgui_set_type(drgui_element* pElement, const char* type);

/// Retrieves the type fo the element.
const char* drgui_get_type(drgui_element* pElement);

/// Determines whether or not the given element is of the given type.
bool drgui_is_of_type(drgui_element* pElement, const char* type);


/// Hides the given element.
void drgui_hide(drgui_element *pElement);

/// Shows the given element.
void drgui_show(drgui_element* pElement);

/// Determines whether or not the element is marked as visible.
///
/// @remarks
///     This is a direct accessor for the internal visible flag of the element and is not recursive. Thus, if this element is
///     marked as visible, but it's parent is invisible, it will still return true. Use drgui_is_visible_recursive() to do
///     a recursive visibility check.
bool drgui_is_visible(const drgui_element* pElement);

/// Recursively determines whether or not the element is marked as visible.
bool drgui_is_visible_recursive(const drgui_element* pElement);


/// Disables clipping against the parent for the given element.
void drgui_disable_clipping(drgui_element* pElement);

/// Enables clipping against the parent for the given element.
void drgui_enable_clipping(drgui_element* pElement);

/// Determines whether or not clipping is enabled for the given element.
bool drgui_is_clipping_enabled(const drgui_element* pElement);


/// Sets the element that should receive all future mouse related events.
///
/// @remarks
///     Release the mouse capture with drgui_release_mosue().
void drgui_capture_mouse(drgui_element* pElement);

/// Releases the mouse capture.
void drgui_release_mouse(drgui_context* pContext);

/// Releases the mouse capture without posting the global-scoped event. Should only be used in very specific cases, usually in combination with awkward interop with the window system.
void drgui_release_mouse_no_global_notify(drgui_context* pContext);

/// Retrieves a pointer to the element with the mouse capture.
drgui_element* drgui_get_element_with_mouse_capture(drgui_context* pContext);

/// Determines whether or not the given element has the mouse capture.
bool drgui_has_mouse_capture(drgui_element* pElement);


/// Sets the element that should receive all future keyboard related events.
///
/// @remarks
///     Releases the keyboard capture with drgui_release_keyboard().
void drgui_capture_keyboard(drgui_element* pElement);

/// Releases the keyboard capture.
void drgui_release_keyboard(drgui_context* pContext);

/// Releases the keyboard capture without posting the global-scoped event. Should only be used in very specific cases, usually in combination with awkward interop with the window system.
void drgui_release_keyboard_no_global_notify(drgui_context* pContext);

/// Retrieves a pointer to the element with the keyboard capture.
drgui_element* drgui_get_element_with_keyboard_capture(drgui_context* pContext);

/// Determines whether or not the given element has the keyboard capture.
bool drgui_has_keyboard_capture(drgui_element* pElement);


/// Sets the cursor to use when the mouse enters the given GUI element.
void drgui_set_cursor(drgui_element* pElement, drgui_cursor_type cursor);

/// Retrieves the cursor to use when the mouse enters the given GUI element.
drgui_cursor_type drgui_get_cursor(drgui_element* pElement);


//// Events ////

/// Registers the on_move event callback.
void drgui_set_on_move(drgui_element* pElement, drgui_on_move_proc callback);

/// Registers the on_size event callback.
void drgui_set_on_size(drgui_element* pElement, drgui_on_size_proc callback);

/// Registers the on_mouse_enter event callback.
void drgui_set_on_mouse_enter(drgui_element* pElement, drgui_on_mouse_enter_proc callback);

/// Registers the on_mouse_leave event callback.
void drgui_set_on_mouse_leave(drgui_element* pElement, drgui_on_mouse_leave_proc callback);

/// Registers the on_mouse_move event callback.
void drgui_set_on_mouse_move(drgui_element* pElement, drgui_on_mouse_move_proc callback);

/// Registers the on_mouse_button_down event callback.
void drgui_set_on_mouse_button_down(drgui_element* pElement, drgui_on_mouse_button_down_proc callback);

/// Registers the on_mouse_button_up event callback.
void drgui_set_on_mouse_button_up(drgui_element* pElement, drgui_on_mouse_button_up_proc callback);

/// Registers the on_mouse_button_down event callback.
void drgui_set_on_mouse_button_dblclick(drgui_element* pElement, drgui_on_mouse_button_dblclick_proc callback);

/// Registers the on_mouse_wheel event callback.
void drgui_set_on_mouse_wheel(drgui_element* pElement, drgui_on_mouse_wheel_proc callback);

/// Registers the on_key_down event callback.
void drgui_set_on_key_down(drgui_element* pElement, drgui_on_key_down_proc callback);

/// Registers the on_key_up event callback.
void drgui_set_on_key_up(drgui_element* pElement, drgui_on_key_up_proc callback);

/// Registers the on_printable_key_down event callback.
void drgui_set_on_printable_key_down(drgui_element* pElement, drgui_on_printable_key_down_proc callback);

/// Registers the on_paint event callback.
void drgui_set_on_paint(drgui_element* pElement, drgui_on_paint_proc callback);

/// Registers the on_dirty event callback.
void drgui_set_on_dirty(drgui_element* pElement, drgui_on_dirty_proc callback);

/// Registers the on_hittest event callback.
void drgui_set_on_hittest(drgui_element* pElement, drgui_on_hittest_proc callback);

/// Registers the on_capture_mouse event callback.
void drgui_set_on_capture_mouse(drgui_element* pElement, drgui_on_capture_mouse_proc callback);

/// Registers the on_release_mouse event callback.
void drgui_set_on_release_mouse(drgui_element* pElement, drgui_on_release_mouse_proc callback);

/// Registers the on_capture_keyboard event callback.
void drgui_set_on_capture_keyboard(drgui_element* pElement, drgui_on_capture_keyboard_proc callback);

/// Registers the on_release_keyboard event callback.
void drgui_set_on_release_keyboard(drgui_element* pElement, drgui_on_release_keyboard_proc callback);



//// Containment and Hit Detection ////

/// Determines whether or not the given point is inside the bounds of the given element.
///
/// @remarks
///     This only checks if the point is inside the bounds of the element and does not take hit testing into account. This difference
///     with this one and drgui_is_point_inside_element() is that the latter will use hit testing.
bool drgui_is_point_inside_element_bounds(const drgui_element* pElement, float absolutePosX, float absolutePosY);

/// Determines whether or not the given point is inside the given element.
///
/// @remarks
///     This will use hit testing to determine whether or not the point is inside the element.
bool drgui_is_point_inside_element(drgui_element* pElement, float absolutePosX, float absolutePosY);

/// Finds the element under the given point taking mouse pass-through and hit testing into account.
drgui_element* drgui_find_element_under_point(drgui_element* pTopLevelElement, float absolutePosX, float absolutePosY);

/// Determines whether or not the given element is currently sitting directly under the mouse.
bool drgui_is_element_under_mouse(drgui_element* pTopLevelElement);



//// Hierarchy ////

// Retrieves the parent of the given element.
drgui_element* drgui_get_parent(drgui_element* pChildElement);

/// Detaches the given element from it's parent.
void drgui_detach(drgui_element* pChildElement);

/// Attaches the given element as a child of the given parent element, and appends it to the end of the children list.
void drgui_append(drgui_element* pChildElement, drgui_element* pParentElement);

/// Attaches the given element as a child of the given parent element, and prepends it to the end of the children list.
void drgui_prepend(drgui_element* pChildElement, drgui_element* pParentElement);

/// Appends the given element to the given sibling.
void drgui_append_sibling(drgui_element* pElementToAppend, drgui_element* pElementToAppendTo);

/// Prepends the given element to the given sibling.
void drgui_prepend_sibling(drgui_element* pElementToPrepend, drgui_element* pElementToPrependTo);

/// Retrieves a pointer to the given element's top-level ancestor.
///
/// @remarks
///     If pElement is the top level element, the return value will be pElement.
drgui_element* drgui_find_top_level_element(drgui_element* pElement);

/// Determines whether or not the given element is the parent of the other.
///
/// @remarks
///     This is not recursive. Use drgui_is_ancestor() to do a recursive traversal.
bool drgui_is_parent(drgui_element* pParentElement, drgui_element* pChildElement);

/// Determines whether or not the given element is a child of the other.
///
/// @remarks
///     This is not recursive. Use drgui_is_descendant() to do a recursive traversal.
bool drgui_is_child(drgui_element* pChildElement, drgui_element* pParentElement);

/// Determines whether or not the given element is an ancestor of the other.
bool drgui_is_ancestor(drgui_element* pAncestorElement, drgui_element* pChildElement);

/// Determines whether or not the given element is a descendant of the other.
bool drgui_is_descendant(drgui_element* pChildElement, drgui_element* pAncestorElement);

/// Determines whether or not the given element is itself or a descendant.
bool drgui_is_self_or_ancestor(drgui_element* pAncestorElement, drgui_element* pChildElement);

/// Determines whether or not the given element is itself or a descendant.
bool drgui_is_self_or_descendant(drgui_element* pChildElement, drgui_element* pAncestorElement);



//// Layout ////

/// Sets the absolute position of the given element.
void drgui_set_absolute_position(drgui_element* pElement, float positionX, float positionY);

/// Retrieves the absolute position of the given element.
void drgui_get_absolute_position(const drgui_element* pElement, float* positionXOut, float* positionYOut);
float drgui_get_absolute_position_x(const drgui_element* pElement);
float drgui_get_absolute_position_y(const drgui_element* pElement);


/// Sets the relative position of the given element.
void drgui_set_relative_position(drgui_element* pElement, float relativePosX, float relativePosY);

/// Retrieves the relative position of the given element.
void drgui_get_relative_position(const drgui_element* pElement, float* relativePosXOut, float* relativePosYOut);
float drgui_get_relative_position_x(const drgui_element* pElement);
float drgui_get_relative_position_y(const drgui_element* pElement);


/// Sets the size of the given element.
void drgui_set_size(drgui_element* pElement, float width, float height);

/// Retrieves the size of the given element.
void drgui_get_size(const drgui_element* pElement, float* widthOut, float* heightOut);
float drgui_get_width(const drgui_element* pElement);
float drgui_get_height(const drgui_element* pElement);



/// Retrieves the absolute rectangle for the given element.
drgui_rect drgui_get_absolute_rect(const drgui_element* pElement);

/// Retrieves the relative rectangle for the given element.
drgui_rect drgui_get_relative_rect(const drgui_element* pElement);

/// Retrieves the local rectangle for the given element.
///
/// @remarks
///     The local rectangle is equivalent to drgui_make_rect(0, 0, drgui_get_width(pElement), drgui_get_height(pElement));
drgui_rect drgui_get_local_rect(const drgui_element* pElement);



//// Painting ////

/// Registers the custom painting callbacks.
///
/// @remarks
///     This can only be called once, so it should always be done after initialization. This will fail if called
///     more than once.
bool drgui_register_painting_callbacks(drgui_context* pContext, void* pPaintingContext, drgui_painting_callbacks callbacks);


/// Performs a recursive traversal of all visible elements in the given rectangle.
///
/// @param pParentElement [in] A pointer to the element to iterate.
///
/// @remarks
///     pParentElement will be included in the iteration is it is within the rectangle.
///     @par
///     The rectangle should be relative to pParentElement.
///     @par
///     The iteration callback function takes a pointer to a rectangle structure that represents the visible portion of the
///     element. This pointer can be modified by the callback to create an adjusted rectangle which can be used for clipping.
bool drgui_iterate_visible_elements(drgui_element* pParentElement, drgui_rect relativeRect, drgui_visible_iteration_proc callback, void* pUserData);


/// Disable's automatic dirtying of elements.
void drgui_disable_auto_dirty(drgui_context* pContext);

/// Enable's automatic dirtying of elements.
void drgui_enable_auto_dirty(drgui_context* pContext);

/// Determines whether or not automatic dirtying is enabled.
bool drgui_is_auto_dirty_enabled(drgui_context* pContext);


/// Begins accumulating a dirty rectangle.
///
/// Returns a pointer to the top level element that was made dirty.
drgui_element* drgui_begin_dirty(drgui_element* pElement);

/// Ends accumulating a dirty rectangle, and requests a redraw from the backend if the counter reaches zero.
void drgui_end_dirty(drgui_element* pElement);

/// Marks a region of the given element as dirty.
///
/// @remarks
///     This will not redraw the element immediately, but instead post a paint event.
void drgui_dirty(drgui_element* pElement, drgui_rect relativeRect);


/// Draws the given element.
///
/// @remarks
///     Do not call this on one element, then again on it's children. Any children that fall inside the specified
///     rectangle will also be redrawn.
///     @par
///     This will call painting event handlers which will give the application time to do custom drawing.
///     @par
///     When using easy_draw to do drawing, pPaintData must be set to a pointer to the relevant easydraw_surface object.
void drgui_draw(drgui_element* pElement, drgui_rect relativeRect, void* pPaintData);

/// Retrieves the current clipping rectangle.
void drgui_get_clip(drgui_element* pElement, drgui_rect* pRelativeRect, void* pPaintData);

/// Sets the clipping rectangle to apply to all future draw operations on this element.
void drgui_set_clip(drgui_element* pElement, drgui_rect relativeRect, void* pPaintData);

/// Draws a rectangle on the given element.
void drgui_draw_rect(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, void* pPaintData);

/// Draws the outline of a rectangle on the given element.
void drgui_draw_rect_outline(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float outlineWidth, void* pPaintData);

/// Draws a filled rectangle with an outline on the given element.
void drgui_draw_rect_with_outline(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float outlineWidth, drgui_color outlineColor, void* pPaintData);

/// Draws a rectangle with rounded corners on the given element.
void drgui_draw_round_rect(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float radius, void* pPaintData);

/// Draws the outline of a rectangle with rounded corners on the given element.
void drgui_draw_round_rect_outline(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float radius, float outlineWidth, void* pPaintData);

/// Draws a filled rectangle and it's outline with rounded corners on the given element.
void drgui_draw_round_rect_with_outline(drgui_element* pElement, drgui_rect relativeRect, drgui_color color, float radius, float outlineWidth, drgui_color outlineColor, void* pPaintData);

/// Draws a run of text on the given element.
///
/// @remarks
///     This does not do any complex formatting like multiple lines and whatnot. Complex formatting can be achieved with multiple
///     calls to this function.
///     @par
///     \c textSizeInBytes can be -1 in which case the text string is treated as null terminated.
void drgui_draw_text(drgui_element* pElement, drgui_font* pFont, const char* text, int textLengthInBytes, float posX, float posY, drgui_color color, drgui_color backgroundColor, void* pPaintData);

/// Draws an image.
void drgui_draw_image(drgui_element* pElement, drgui_image* pImage, drgui_draw_image_args* pArgs, void* pPaintData);


/// Creates a font resource.
drgui_font* drgui_create_font(drgui_context* pContext, const char* family, unsigned int size, drgui_font_weight weight, drgui_font_slant slant, float rotation, unsigned int flags);

/// Deletes a font resource.
void drgui_delete_font(drgui_font* pFont);

/// Retrieves the metrics of the given font.
bool drgui_get_font_metrics(drgui_font* pFont, drgui_font_metrics* pMetricsOut);

/// Retrieves the metrics of the glyph for the given character when rendered with the given font.
bool drgui_get_glyph_metrics(drgui_font* pFont, unsigned int utf32, drgui_glyph_metrics* pMetricsOut);

/// Retrieves the dimensions of the given string when drawn with the given font.
///
/// @remarks
///     When the length of the text is 0, the width will be set to 0 and the height will be set to the line height.
bool drgui_measure_string(drgui_font* pFont, const char* text, size_t textLengthInBytes, float* pWidthOut, float* pHeightOut);

/// Retrieves the position to place a text cursor based on the given point for the given string when drawn with the given font.
bool drgui_get_text_cursor_position_from_point(drgui_font* pFont, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float* pTextCursorPosXOut, size_t* pCharacterIndexOut);

/// Retrieves the position to palce a text cursor based on the character at the given index for the given string when drawn with the given font.
bool drgui_get_text_cursor_position_from_char(drgui_font* pFont, const char* text, size_t characterIndex, float* pTextCursorPosXOut);



/// Creates an image that can be passed to drgui_draw_image().
///
/// @remarks
///     The dimensions and format of an image are immutable. If these need to change, then the image needs to be deleted and re-created.
///     @par
///     If pData is NULL, the default image data is undefined.
///     @par
///     If stride is set to 0, it is assumed to be tightly packed.
///     @par
///     Use drgui_map_image_data() and drgui_unmap_image_data() to update or retrieve image data.
drgui_image* drgui_create_image(drgui_context* pContext, unsigned int width, unsigned int height, drgui_image_format format, unsigned int stride, const void* pData);

/// Deletes the given image.
void drgui_delete_image(drgui_image* pImage);

/// Retrieves the size of the given image.
void drgui_get_image_size(drgui_image* pImage, unsigned int* pWidthOut, unsigned int* pHeightOut);

/// Retrieves the optimal image format for the given context.
drgui_image_format drgui_get_optimal_image_format(drgui_context* pContext);

/// Retrieves a pointer to a buffer representing the given image's data.
///
/// Call drgui_unmap_image_data() when you are done with this function.
///
/// Use this function to access an image's data. The returned pointer does not necessarilly point to the image's actual data, so when
/// writing to this pointer, nothing is actually updated until drgui_unmap_image_data() is called.
///
/// The returned data will contain the image data at the time of the mapping.
void* drgui_map_image_data(drgui_image* pImage, unsigned int accessFlags);

/// Unmaps the given image data.
void drgui_unmap_image_data(drgui_image* pImage);



/////////////////////////////////////////////////////////////////
//
// HIGH-LEVEL API
//
/////////////////////////////////////////////////////////////////

//// Hit Testing and Layout ////

/// An on_size event callback that resizes every child element to that of the parent.
void drgui_on_size_fit_children_to_parent(drgui_element* pElement, float newWidth, float newHeight);

/// An on_hit_test event callback that can be used to always fail the mouse hit test.
bool drgui_pass_through_hit_test(drgui_element* pElement, float mousePosX, float mousePosY);


//// Painting ////

/// Draws a border around the given element.
void drgui_draw_border(drgui_element* pElement, float borderWidth, drgui_color color, void* pUserData);



/////////////////////////////////////////////////////////////////
//
// UTILITY API
//
/////////////////////////////////////////////////////////////////

/// Creates a color object from a set of RGBA color components.
drgui_color drgui_rgba(drgui_byte r, drgui_byte g, drgui_byte b, drgui_byte a);

/// Creates a color object from a set of RGB color components.
drgui_color drgui_rgb(drgui_byte r, drgui_byte g, drgui_byte b);

/// Clamps the given rectangle to another.
drgui_rect drgui_clamp_rect(drgui_rect rect, drgui_rect other);

/// Clamps the given rectangle to the given element and returns whether or not any of it is contained within the element's rectangle.
bool drgui_clamp_rect_to_element(const drgui_element* pElement, drgui_rect* pRelativeRect);

/// Converts the given rectangle from absolute to relative to the given element.
drgui_rect drgui_make_rect_relative(const drgui_element* pElement, drgui_rect* pRect);

/// Converts the given rectangle from relative to absolute based on the given element.
drgui_rect drgui_make_rect_absolute(const drgui_element* pElement, drgui_rect* pRect);

/// Converts the given point from absolute to relative to the given element.
void drgui_make_point_relative(const drgui_element* pElement, float* positionX, float* positionY);

/// Converts the given point from relative to absolute based on the given element.
void drgui_make_point_absolute(const drgui_element* pElement, float* positionX, float* positionY);

/// Creates a drgui_rect object.
drgui_rect drgui_make_rect(float left, float top, float right, float bottom);

/// Creates an inside-out rectangle.
///
/// @remarks
///     An inside our rectangle is a negative-dimension rectangle with each edge at the extreme edges. The left edge will be at the
///     right-most side and the right edge will be at the left-most side. The same applies for the top and bottom edges.
drgui_rect drgui_make_inside_out_rect();

/// Expands the given rectangle on all sides by the given amount.
///
/// @remarks
///     This will increase the width and height of the rectangle by <amount> x 2.
///     @par
///     The growth amount can be negative, in which case it will be shrunk. Note that this does not do any checking to ensure the rectangle
///     contains positive dimensions after a shrink.
drgui_rect drgui_grow_rect(drgui_rect rect, float amount);

/// Scales the given rectangle.
///
/// @param scaleX [in] The scale to apply to <left> and <right>
/// @param scaleY [in] The scale to apply to <top> and <bottom>
///
/// @remarks
///     This will modify the <left> and <top> properties which means the rectangle will change position. To adjust only the size, scale the
///     rectangle manually.
drgui_rect drgui_scale_rect(drgui_rect rect, float scaleX, float scaleY);

/// Offsets the given rectangle.
drgui_rect drgui_offset_rect(drgui_rect rect, float offsetX, float offsetY);

/// Creates a rectangle that contains both of the given rectangles.
drgui_rect drgui_rect_union(drgui_rect rect0, drgui_rect rect1);

/// Determines whether or not the given rectangle contains the given point.
///
/// @remarks
///     An important not here is that if the position is sitting on the right or bottom border, false will be returned. If, however, the point
///     is sitting on the left or top border, true will be returned. The reason for this is that elements may sit exactly side-by-side with
///     each other, and if we use this function to determine if a point is contained within an element (which we do), we would end up having
///     this return true for both elements, which we don't want.
bool drgui_rect_contains_point(drgui_rect rect, float posX, float posY);

/// Determines whether or not two rectangles are equal.
bool drgui_rect_equal(drgui_rect rect0, drgui_rect rect1);

/// Determines whether or not the given rectangle has any volume (width and height > 0).
bool drgui_rect_has_volume(drgui_rect rect);



/////////////////////////////////////////////////////////////////
//
// DR_2D-SPECIFIC API
//
/////////////////////////////////////////////////////////////////
#ifndef DRGUI_NO_DR_2D

/// A covenience function for creating a new context and registering the easy_draw painting callbacks.
///
/// @remarks
///     This is equivalent to drgui_create_context() followed by drgui_register_dr_2d_callbacks().
drgui_context* drgui_create_context_dr_2d(dr2d_context* pDrawingContext);

/// Registers the drawing callbacks for use with easy_draw.
///
/// @remarks
///     The user data of each callback is assumed to be a pointer to an easydraw_surface object.
void drgui_register_dr_2d_callbacks(drgui_context* pContext, dr2d_context* pDrawingContext);

#endif
