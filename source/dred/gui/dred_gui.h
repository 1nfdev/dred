// Copyright (C) 2016 David Reid. See included LICENSE file.

// QUICK NOTES
//
// General
// - dr_gui is a low-level GUI system that works on generic objects referred to as "elements".
// - An element is the most basic unit in dr_gui. It contains basic information about it's layout and hierarchy.
// - Controls can be used as the building blocks for more complex controls such as list boxes and scrollbars.
// - The layout of elements use floats instead of integers. The rationale for this is that it makes it easier to do certain
//   layout arithmetic. For example, if you want to evenly distribute 3 elements across a fixed area, the integer based
//   arithmetic can cause rounding errors which cause the elements to not sit flush against the area. By using float-based
//   arithmetic we can avoid that particular issue.
//
// Hierarchy
// - An element can have a parent and any number of children. If an element does not have a parent, it is referred to as the
//   top-level element.
// - When an element is deleted, it's children will be deleted as well.
// - Top-level elements do not have siblings.
//
// Event Handling
// - The application must notify dr_gui of application-generated events such as key strokes and mouse movements. These are
//   referred to as inbound events. An event that is generated by dr_gui are referred to as outbound events.
// - Inbound events are used to generate outbound events. For example, a mouse-move inbound event will generate an outbound
//   mouse-move event, and perhaps a mouse leave/enter pair.
// - Outbound events are posted and handled immediately. A call to drgui_post_inbound_event() will not return until all of
//   the outbound events it generates have been handled.
// - Inbound events are not thread safe, however an application is free to post an inbound event from any thread so long as
//   it does it's own synchronization.
// - Inbound events will typically specify the relevant top-level element and let dr_gui do the relevant processing required
//   to generate the appropriate outbound events. For example, the mouse-move event will be specified with respect to the top-
//   level element, but dr_gui will determine the exact child element that the mouse moved on and thus should receive the
//   relevant outbound mouse-move event.
// - There are some special events that are handled differently to normal events. The best example is the paint events. The
//   paint event is only called from dred_control_draw().
// - Key press/release events are only ever posted to the element that has the keyboard capture/focus which is set with
//   dred_gui_capture_keyboard(). Thus, when posting an inbound key event, a top-level element is not required when posting
//   those events. The relevant context is still required, however.
//
// Global Outbound Event Handling
// - At times dr_gui will need to notify the host application in order for certain functionality to work properly. For example.
//   when the mouse is captured it won't work 100% correct unless the host application has a chance to capture the mouse against
//   the container window. Because dr_gui has no notion of a window system it relies on the host application to handle this
//   properly.
// - A global outbound event handler should be implemented for each of the following events:
//   - on_dirty: Called when a region of an element is marked as dirty and needs to be redrawn. The application will want to
//     invalidate the container window to trigger an operating system redraw. Set this with dred_gui_set_global_on_dirty().
//   - on_capture_mouse: Called when the mouse is captured and gives the application the opportunity to capture the mouse against
//     the container window at the operating system level. Set with dred_gui_set_global_on_capture_mouse().
//   - on_release_mouse: Called when the mouse is released. The opposite of on_capture_mouse.
//   - on_capture_keyboard: Called when an element is given the keyboard focus and gives the application the opportunity to
//     apply the keyboard focus to the container window. Set with dred_gui_set_global_on_capture_keyboard().
//   - on_release_keyboard: Called when an element loses the keyboard focus. The opposite of on_capture_keyboard.
//   - on_change_cursor: Called when the current cursor needs to be changed as a result of the mouse moving over a new element.
//
// Layout
// - An element's data structure does not store it's relative position but instead stores it's absolute position. The rationale
//   for this is that storing it as relative complicates absolute positioning calculations because it would need to do a recursive
//   traversal of the element's ancestors.
// - Child elements can be scaled by setting an element's inner scale. The inner scale does not scale the element itself - only
//   it's children.
// - When an element is drawn, everything is scaled by it's inner scale. For example, if the inner scale is 2x and a 100x100 quad
//   is drawn, the quad will be scaled to 200x200. An exception to this rule is fonts, which are never scaled. This 0s because
//   text is always drawn based on the size of the font.
// - Applications should only need to work on unscaled coordinates. That is, an application should never need to worry about
//   manual scaling, except for fonts. When positioning and sizing child elements, they should be done based on unscaled
//   coordinates.
// - Use the inner scale system for DPI awareness.
// - The inner scale is applied recursively. That is, if a top level element has it's inner scale set to 2x and one of it's
//   children has an inner scale of 2x, the actual inner scale of the child element will be 4x.
//
//
// Drawing/Painting
// - Drawing is one of the more complex parts of the GUI because it can be a bit unintuitive regarding exactly when an element
//   is drawn and when a drawing function is allowed to be called.
// - To draw an element, call dred_control_draw(). This takes a pointer to the element to draw and the rectangle region that should
//   be redrawn. Any children that fall inside the specified rectangle region will be redrawn as well. You do not want to call
//   dred_control_draw() on a parent element and then again on it's children because dr_gui will do that automatically.
// - dred_control_draw() does not draw anything directly, but rather calls painting callback routines which is where the actual
//   drawing takes place.
// - Sometimes an application will need to be told when a region of an element is dirty and needs redrawing. An example is
//   event-driven, non real-time applications such as normal desktop applications. To mark an element as dirty, you call the
//   dred_control_dirty() function which takes the element that is dirty, and the rectangle region that needs to be redrawn. This
//   does not redraw the element immediately, but instead posts an on_dirty event for the application. Marking regions as dirty
//   is not strictly required, but you should prefer it for event-driven applications that require painting operations to be
//   performed at specific times (such as inside Win32's WM_PAINT messages).
// - Some operations will cause a region of an element to become dirty - such as when it is resized. dr_gui will
//   automatically mark the relevant regions as dirty which in turn will cause a paint message to be posted. If this is not
//   required, it can be disabled with dred_gui_disable_auto_dirty(). You may want to disable automatic dirtying if you are
//   running a real-time application like a game which would redraw the entire GUI every frame anyway and thus not require
//   handling of the paint message.
// - Real-time application guidelines (games, etc.):
//   - dred_gui_disable_auto_dirty()
//   - dred_control_draw(pTopLevelControl, 0, 0, viewportWidth, viewportHeight) at the end of every frame after your main loop.
//


//
// OPTIONS
//
// #define DRED_GUI_NO_DR_2D
//   Disable dr_2d integration. Disabling dr_2d will require you to implement your own drawing callbacks.
//
// #define DRED_GUI_NO_TEXT_EDITING
//   Disables the text box control and text engine.


//
// EXAMPLES
//
// Basic Drawing:
//
// dred_control_draw(pTopLevelControl, 0, 0, dred_control_get_width(pTopLevelControl), dred_control_get_height(pTopLevelControl));
//
// -------------------------
//
// Event-Driven Drawing (Win32):
//
// void my_global_on_dirty_win32(dred_control* pControl, dred_rect relativeRect) {
//     dred_rect absoluteRect = relativeRect;
//     drgui_make_rect_absolute(pControl, &absoluteRect);
//
//     RECT rect;
//     rect.left   = absoluteRect.left;
//     rect.top    = absoluteRect.top;
//     rect.right  = absoluteRect.right;
//     rect.height = absoluteRect.bottom;
//     InvalidateRect((HWND)drgui_get_user_data(dred_control_find_top_level_control(pControl)), &rect, FALSE);
// }
//
// ...
//
// LRESULT CALLBACK MyWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
//     ...
//     dred_control* pTopLevelControl = (dred_control*)GetWindowLongPtr(hWnd, 0);
//     if (pTopLevelControl != NULL) {
//         switch (msg) {
//             ...
//             case WM_PAINT:
//             {
//                 RECT rect;
//                 if (GetUpdateRect(hWnd, &rect, FALSE)) {
//                     dred_control_draw(pTopLevelControl, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
//                 }
//
//                 break;
//             }
//             ...
//         }
//     }
//     ...
// }
//

#ifndef DRED_MAX_FONT_FAMILY_LENGTH
#define DRED_MAX_FONT_FAMILY_LENGTH  128
#endif

typedef struct dred_gui dred_gui;
typedef struct dred_control dred_control;
typedef struct dred_color dred_color;
typedef struct dred_rect dred_rect;
typedef struct dred_gui_painting_callbacks dred_gui_painting_callbacks;
typedef struct dred_gui_font dred_gui_font;
typedef struct dred_gui_image dred_gui_image;
typedef struct dred_gui_font_metrics dred_gui_font_metrics;
typedef struct dred_glyph_metrics dred_glyph_metrics;

typedef unsigned int dred_key;

typedef void* dred_gui_resource;

/// Common system cursors.
typedef enum
{
    dred_cursor_none,
    dred_cursor_default,
    dred_cursor_arrow = dred_cursor_default,
    dred_cursor_text,
    dred_cursor_cross,
    dred_cursor_size_ns,           // North/South resize arrows.
    dred_cursor_size_we,           // West/East resize arrows.
    dred_cursor_size_nesw,         // North/East, South/West resize arrows.
    dred_cursor_size_nwse          // North/West, South/East resize arrows.
} dred_cursor_type;

/// Font weights.
typedef enum
{
    dred_gui_font_weight_medium,
    dred_gui_font_weight_thin,
    dred_gui_font_weight_extra_light,
    dred_gui_font_weight_light,
    dred_gui_font_weight_semi_light,
    dred_gui_font_weight_book,
    dred_gui_font_weight_semi_bold,
    dred_gui_font_weight_bold,
    dred_gui_font_weight_extra_bold,
    dred_gui_font_weight_heavy,
    dred_gui_font_weight_extra_heavy,

    dred_gui_font_weight_normal  = dred_gui_font_weight_medium,
    dred_gui_font_weight_default = dred_gui_font_weight_medium

} dred_gui_font_weight;

/// Font slants.
typedef enum
{
    dred_gui_font_slant_none,
    dred_gui_font_slant_italic,
    dred_gui_font_slant_oblique

} dred_gui_font_slant;

/// Image formats.
typedef enum
{
    dred_gui_image_format_rgba8,
    dred_gui_image_format_bgra8,
    dred_gui_image_format_argb8,
} dred_gui_image_format;


/// Font metrics.
struct dred_gui_font_metrics
{
    int ascent;
    int descent;
    int lineHeight;
    int spaceWidth;
};

/// Glyph metrics.
struct dred_glyph_metrics
{
    int width;
    int height;
    int originX;
    int originY;
    int advanceX;
    int advanceY;
};


/// Structure representing an RGBA color. Color components are specified in the range of 0 - 255.
struct dred_color
{
    uint8_t r;
    uint8_t g;
    uint8_t b;
    uint8_t a;
};

/// Structure representing a rectangle.
struct dred_rect
{
    float left;
    float top;
    float right;
    float bottom;
};


#define DRED_GUI_IMAGE_DRAW_BACKGROUND     (1 << 0)
#define DRED_GUI_IMAGE_HINT_NO_ALPHA       (1 << 1)
#define DRED_GUI_IMAGE_DRAW_BOUNDS         (1 << 2)
#define DRED_GUI_IMAGE_CLIP_BOUNDS         (1 << 3)        //< Clips the image to the bounds
#define DRED_GUI_IMAGE_ALIGN_CENTER        (1 << 4)

#define DRED_GUI_READ                      (1 << 0)
#define DRED_GUI_WRITE                     (1 << 1)

#define DRED_GUI_FONT_NO_CLEARTYPE         (1 << 0)

typedef struct
{
    /// The destination position on the x axis. This is ignored if the DR2D_IMAGE_ALIGN_CENTER option is set.
    float dstX;

    /// The destination position on the y axis. This is ignored if the DR2D_IMAGE_ALIGN_CENTER option is set.
    float dstY;

    /// The destination width.
    float dstWidth;

    /// The destination height.
    float dstHeight;


    /// The source offset on the x axis.
    float srcX;

    /// The source offset on the y axis.
    float srcY;

    /// The source width.
    float srcWidth;

    /// The source height.
    float srcHeight;


    /// The position of the destination's bounds on the x axis.
    float dstBoundsX;

    /// The position of the destination's bounds on the y axis.
    float dstBoundsY;

    /// The width of the destination's bounds.
    float dstBoundsWidth;

    /// The height of the destination's bounds.
    float dstBoundsHeight;


    /// The foreground tint color. This is not applied to the background color, and the alpha component is ignored.
    dred_color foregroundTint;

    /// The background color. Only used if the DR2D_IMAGE_DRAW_BACKGROUND option is set.
    dred_color backgroundColor;

    /// The bounds color. This color is used for the region of the bounds that sit on the outside of the destination rectangle. This will
    /// usually be set to the same value as backgroundColor, but it could also be used to draw a border around the image.
    dred_color boundsColor;


    /// Flags for controlling how the image should be drawn.
    unsigned int options;

} dred_gui_draw_image_args;


typedef void (* dred_gui_on_move_proc)                 (dred_control* pControl, float newRelativePosX, float newRelativePosY);
typedef void (* dred_gui_on_size_proc)                 (dred_control* pControl, float newWidth, float newHeight);
typedef void (* dred_gui_on_mouse_enter_proc)          (dred_control* pControl);
typedef void (* dred_gui_on_mouse_leave_proc)          (dred_control* pControl);
typedef void (* dred_gui_on_mouse_move_proc)           (dred_control* pControl, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_mouse_button_down_proc)    (dred_control* pControl, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_mouse_button_up_proc)      (dred_control* pControl, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_mouse_button_dblclick_proc)(dred_control* pControl, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_mouse_wheel_proc)          (dred_control* pControl, int delta, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_key_down_proc)             (dred_control* pControl, dred_key key, int stateFlags);
typedef void (* dred_gui_on_key_up_proc)               (dred_control* pControl, dred_key key, int stateFlags);
typedef void (* dred_gui_on_printable_key_down_proc)   (dred_control* pControl, unsigned int character, int stateFlags);
typedef void (* dred_gui_on_paint_proc)                (dred_control* pControl, dred_rect relativeRect, void* pPaintData);
typedef void (* dred_gui_on_dirty_proc)                (dred_control* pControl, dred_rect relativeRect);
typedef bool (* dred_gui_on_hittest_proc)              (dred_control* pControl, float relativePosX, float relativePosY);
typedef void (* dred_gui_on_capture_mouse_proc)        (dred_control* pControl);
typedef void (* dred_gui_on_release_mouse_proc)        (dred_control* pControl);
typedef void (* dred_gui_on_capture_keyboard_proc)     (dred_control* pControl, dred_control* pPrevCapturedControl);
typedef void (* dred_gui_on_release_keyboard_proc)     (dred_control* pControl, dred_control* pNewCapturedControl);
typedef void (* dred_gui_on_change_cursor_proc)        (dred_control* pControl, dred_cursor_type cursor);
typedef void (* dred_gui_on_delete_element_proc)       (dred_control* pControl);
typedef void (* dred_gui_on_log)                       (dred_gui* pGUI, const char* message);

typedef void (* dred_gui_draw_begin_proc)                   (void* pPaintData);
typedef void (* dred_gui_draw_end_proc)                     (void* pPaintData);
typedef void (* dred_gui_set_clip_proc)                     (dred_rect relativeRect, void* pPaintData);
typedef void (* dred_gui_get_clip_proc)                     (dred_rect* pRectOut, void* pPaintData);
typedef void (* dred_gui_draw_line_proc)                    (float startX, float startY, float endX, float endY, float width, dred_color color, void* pPaintData);
typedef void (* dred_gui_draw_rect_proc)                    (dred_rect relativeRect, dred_color color, void* pPaintData);
typedef void (* dred_gui_draw_rect_outline_proc)            (dred_rect relativeRect, dred_color color, float outlineWidth, void* pPaintData);
typedef void (* dred_gui_draw_rect_with_outline_proc)       (dred_rect relativeRect, dred_color color, float outlineWidth, dred_color outlineColor, void* pPaintData);
typedef void (* dred_gui_draw_round_rect_proc)              (dred_rect relativeRect, dred_color color, float radius, void* pPaintData);
typedef void (* dred_gui_draw_round_rect_outline_proc)      (dred_rect relativeRect, dred_color color, float radius, float outlineWidth, void* pPaintData);
typedef void (* dred_gui_draw_round_rect_with_outline_proc) (dred_rect relativeRect, dred_color color, float radius, float outlineWidth, dred_color outlineColor, void* pPaintData);
typedef void (* dred_gui_draw_text_proc)                    (dred_gui_resource font, const char* text, int textLengthInBytes, float posX, float posY, dred_color color, dred_color backgroundColor, void* pPaintData);
typedef void (* dred_gui_draw_image_proc)                   (dred_gui_resource image, dred_gui_draw_image_args* pArgs, void* pPaintData);

typedef dred_gui_resource (* dred_gui_create_font_proc)                        (void* pPaintingContext, const char* family, unsigned int size, dred_gui_font_weight weight, dred_gui_font_slant slant, float rotation, unsigned int flags);
typedef void              (* dred_gui_delete_font_proc)                        (dred_gui_resource font);
typedef unsigned int      (* dred_gui_get_font_size_proc)                      (dred_gui_resource font);
typedef bool              (* dred_gui_get_font_metrics_proc)                   (dred_gui_resource font, dred_gui_font_metrics* pMetricsOut);
typedef bool              (* dred_gui_get_glyph_metrics_proc)                  (dred_gui_resource font, unsigned int utf32, dred_glyph_metrics* pMetricsOut);
typedef bool              (* dred_gui_measure_string_proc)                     (dred_gui_resource font, const char* text, size_t textSizeInBytes, float* pWidthOut, float* pHeightOut);
typedef bool              (* dred_gui_get_text_cursor_position_from_point_proc)(dred_gui_resource font, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float* pTextCursorPosXOut, size_t* pCharacterIndexOut);
typedef bool              (* dred_gui_get_text_cursor_position_from_char_proc) (dred_gui_resource font, const char* text, size_t characterIndex, float* pTextCursorPosXOut);

typedef dred_gui_resource     (* dred_gui_create_image_proc)            (void* pPaintingContext, unsigned int width, unsigned int height, dred_gui_image_format format, unsigned int stride, const void* pImageData);
typedef void                  (* dred_gui_delete_image_proc)            (dred_gui_resource image);
typedef dred_gui_image_format (* dred_gui_get_optimal_image_format_proc)(void* pPaintingContext);
typedef void                  (* dred_gui_get_image_size_proc)          (dred_gui_resource image, unsigned int* pWidthOut, unsigned int* pHeightOut);
typedef void*                 (* dred_gui_map_image_data_proc)          (dred_gui_resource image, unsigned int accessFlags);
typedef void                  (* dred_gui_unmap_image_data_proc)        (dred_gui_resource image);

typedef bool (* dred_gui_visible_iteration_proc)(dred_control* pControl, dred_rect *pRelativeRect, void* pUserData);


// Key state flags.
#define DRED_GUI_MOUSE_BUTTON_LEFT_DOWN   (1 << 0)
#define DRED_GUI_MOUSE_BUTTON_RIGHT_DOWN  (1 << 1)
#define DRED_GUI_MOUSE_BUTTON_MIDDLE_DOWN (1 << 2)
#define DRED_GUI_MOUSE_BUTTON_4_DOWN      (1 << 3)
#define DRED_GUI_MOUSE_BUTTON_5_DOWN      (1 << 4)
#define DRED_GUI_KEY_STATE_SHIFT_DOWN     (1 << 5)        // Whether or not a shift key is down at the time the input event is handled.
#define DRED_GUI_KEY_STATE_CTRL_DOWN      (1 << 6)        // Whether or not a ctrl key is down at the time the input event is handled.
#define DRED_GUI_KEY_STATE_ALT_DOWN       (1 << 7)        // Whether or not an alt key is down at the time the input event is handled.
#define DRED_GUI_KEY_STATE_AUTO_REPEATED  (1 << 31)       // Whether or not the key press is generated due to auto-repeating. Only used with key down events.

// Common mouse buttons.
#define DRED_GUI_MOUSE_BUTTON_LEFT      1
#define DRED_GUI_MOUSE_BUTTON_RIGHT     2
#define DRED_GUI_MOUSE_BUTTON_MIDDLE    3

// Common key codes.
#define DRED_GUI_BACKSPACE              0xff08
#define DRED_GUI_SHIFT                  0xff10
#define DRED_GUI_ESCAPE                 0xff1b
#define DRED_GUI_PAGE_UP                0xff55
#define DRED_GUI_PAGE_DOWN              0xff56
#define DRED_GUI_END                    0xff57
#define DRED_GUI_HOME                   0xff50
#define DRED_GUI_ARROW_LEFT             0x8fb
#define DRED_GUI_ARROW_UP               0x8fc
#define DRED_GUI_ARROW_RIGHT            0x8fd
#define DRED_GUI_ARROW_DOWN             0x8fe
#define DRED_GUI_DELETE                 0xffff
#define DRED_GUI_F1                     0xffbe
#define DRED_GUI_F2                     0xffbf
#define DRED_GUI_F3                     0xffc0
#define DRED_GUI_F4                     0xffc1
#define DRED_GUI_F5                     0xffc2
#define DRED_GUI_F6                     0xffc3
#define DRED_GUI_F7                     0xffc4
#define DRED_GUI_F8                     0xffc5
#define DRED_GUI_F9                     0xffc6
#define DRED_GUI_F10                    0xffc7
#define DRED_GUI_F11                    0xffc8
#define DRED_GUI_F12                    0xffc9

static size_t dred_gui_strcpy_len(char* dst, size_t dstSize, const char* src)
{
    if (strcpy_s(dst, dstSize, src) == 0) {
        return strlen(dst);
    }

    return 0;
}

static inline size_t dred_key_to_string(dred_key key, char* strOut, size_t strOutSize)
{
    if (strOut == NULL || strOutSize == 0) {
        return 0;
    }

    if (strOutSize == 1) {
        strOut[0] = '\0';
        return 0;
    }


    switch (key)
    {
    case DRED_GUI_BACKSPACE:   return dred_gui_strcpy_len(strOut, strOutSize, "Backspace");
    case DRED_GUI_SHIFT:       return dred_gui_strcpy_len(strOut, strOutSize, "Shift");
    case DRED_GUI_ESCAPE:      return dred_gui_strcpy_len(strOut, strOutSize, "Escape");
    case DRED_GUI_PAGE_UP:     return dred_gui_strcpy_len(strOut, strOutSize, "Page Up");
    case DRED_GUI_PAGE_DOWN:   return dred_gui_strcpy_len(strOut, strOutSize, "Page Down");
    case DRED_GUI_END:         return dred_gui_strcpy_len(strOut, strOutSize, "End");
    case DRED_GUI_HOME:        return dred_gui_strcpy_len(strOut, strOutSize, "Home");
    case DRED_GUI_ARROW_LEFT:  return dred_gui_strcpy_len(strOut, strOutSize, "Arrow Left");
    case DRED_GUI_ARROW_UP:    return dred_gui_strcpy_len(strOut, strOutSize, "Arrow Up");
    case DRED_GUI_ARROW_RIGHT: return dred_gui_strcpy_len(strOut, strOutSize, "Arrow Right");
    case DRED_GUI_ARROW_DOWN:  return dred_gui_strcpy_len(strOut, strOutSize, "Arrow Down");
    case DRED_GUI_DELETE:      return dred_gui_strcpy_len(strOut, strOutSize, "Delete");
    case DRED_GUI_F1:          return dred_gui_strcpy_len(strOut, strOutSize, "F1");
    case DRED_GUI_F2:          return dred_gui_strcpy_len(strOut, strOutSize, "F2");
    case DRED_GUI_F3:          return dred_gui_strcpy_len(strOut, strOutSize, "F3");
    case DRED_GUI_F4:          return dred_gui_strcpy_len(strOut, strOutSize, "F4");
    case DRED_GUI_F5:          return dred_gui_strcpy_len(strOut, strOutSize, "F5");
    case DRED_GUI_F6:          return dred_gui_strcpy_len(strOut, strOutSize, "F6");
    case DRED_GUI_F7:          return dred_gui_strcpy_len(strOut, strOutSize, "F7");
    case DRED_GUI_F8:          return dred_gui_strcpy_len(strOut, strOutSize, "F8");
    case DRED_GUI_F9:          return dred_gui_strcpy_len(strOut, strOutSize, "F9");
    case DRED_GUI_F10:         return dred_gui_strcpy_len(strOut, strOutSize, "F10");
    case DRED_GUI_F11:         return dred_gui_strcpy_len(strOut, strOutSize, "F11");
    case DRED_GUI_F12:         return dred_gui_strcpy_len(strOut, strOutSize, "F12");
    }

    if (key >= 32 && key <= 126) {
        strOut[0] = (char)key;
        strOut[1] = '\0';
        return 1;
    }

    // TODO: Non-ascii characters.
    return 0;
}

dred_key dred_key_parse(const char* str)
{
    if (str == NULL || str[0] == '\0') {
        return 0;
    }

    if (_stricmp(str, "backspace")   == 0) return DRED_GUI_BACKSPACE;
    if (_stricmp(str, "shift")       == 0) return DRED_GUI_SHIFT;
    if (_stricmp(str, "escape")      == 0) return DRED_GUI_ESCAPE;
    if (_stricmp(str, "page up")     == 0 || _stricmp(str, "pageup")     == 0) return DRED_GUI_PAGE_UP;
    if (_stricmp(str, "page down")   == 0 || _stricmp(str, "pagedown")   == 0) return DRED_GUI_PAGE_DOWN;
    if (_stricmp(str, "end")         == 0) return DRED_GUI_END;
    if (_stricmp(str, "home")        == 0) return DRED_GUI_HOME;
    if (_stricmp(str, "arrow left")  == 0 || _stricmp(str, "arrowleft")  == 0) return DRED_GUI_ARROW_LEFT;
    if (_stricmp(str, "arrow up")    == 0 || _stricmp(str, "arrowup")    == 0) return DRED_GUI_ARROW_UP;
    if (_stricmp(str, "arrow right") == 0 || _stricmp(str, "arrowright") == 0) return DRED_GUI_ARROW_RIGHT;
    if (_stricmp(str, "arrow down")  == 0 || _stricmp(str, "arrowdown")  == 0) return DRED_GUI_ARROW_DOWN;
    if (_stricmp(str, "delete")      == 0) return DRED_GUI_BACKSPACE;

    if (str[0] == 'F' || str[0] == 'f') {
        if (str[1] ==  '1') {
            if (str[2] == '\0') {
                return DRED_GUI_F1;
            } else {
                if (str[2] == '0' && str[2] == '\0') return DRED_GUI_F10;
                if (str[2] == '1' && str[2] == '\0') return DRED_GUI_F11;
                if (str[2] == '2' && str[2] == '\0') return DRED_GUI_F12;
            }
        }
        if (str[1] == '2' && str[2] == '\0') return DRED_GUI_F2;
        if (str[1] == '3' && str[2] == '\0') return DRED_GUI_F3;
        if (str[1] == '4' && str[2] == '\0') return DRED_GUI_F4;
        if (str[1] == '5' && str[2] == '\0') return DRED_GUI_F5;
        if (str[1] == '6' && str[2] == '\0') return DRED_GUI_F6;
        if (str[1] == '7' && str[2] == '\0') return DRED_GUI_F7;
        if (str[1] == '8' && str[2] == '\0') return DRED_GUI_F8;
        if (str[1] == '9' && str[2] == '\0') return DRED_GUI_F9;
    }


    // ASCII characters.
    if (str[0] >= 32 && str[0] <= 126 && str[1] == '\0') {
        return str[0];
    }

    if (_stricmp(str, "tab") == 0) {
        return '\t';
    }


    // TODO: Non-ascii characters.
    return 0;
}


/// Structure containing callbacks for painting routines.
struct dred_gui_painting_callbacks
{
    dred_gui_draw_begin_proc                          drawBegin;
    dred_gui_draw_end_proc                            drawEnd;

    dred_gui_set_clip_proc                            setClip;
    dred_gui_get_clip_proc                            getClip;

    dred_gui_draw_line_proc                           drawLine;
    dred_gui_draw_rect_proc                           drawRect;
    dred_gui_draw_rect_outline_proc                   drawRectOutline;
    dred_gui_draw_rect_with_outline_proc              drawRectWithOutline;
    dred_gui_draw_round_rect_proc                     drawRoundRect;
    dred_gui_draw_round_rect_outline_proc             drawRoundRectOutline;
    dred_gui_draw_round_rect_with_outline_proc        drawRoundRectWithOutline;
    dred_gui_draw_text_proc                           drawText;
    dred_gui_draw_image_proc                          drawImage;

    dred_gui_create_font_proc                         createFont;
    dred_gui_delete_font_proc                         deleteFont;
    dred_gui_get_font_size_proc                       getFontSize;
    dred_gui_get_font_metrics_proc                    getFontMetrics;
    dred_gui_get_glyph_metrics_proc                   getGlyphMetrics;
    dred_gui_measure_string_proc                      measureString;
    dred_gui_get_text_cursor_position_from_point_proc getTextCursorPositionFromPoint;
    dred_gui_get_text_cursor_position_from_char_proc  getTextCursorPositionFromChar;

    dred_gui_create_image_proc                        createImage;
    dred_gui_delete_image_proc                        deleteImage;
    dred_gui_get_optimal_image_format_proc            getOptimalImageFormat;
    dred_gui_get_image_size_proc                      getImageSize;
    dred_gui_map_image_data_proc                      mapImageData;
    dred_gui_unmap_image_data_proc                    unmapImageData;
};

struct dred_gui_image
{
    /// A pointer to the context that owns this image.
    dred_gui* pGUI;

    /// The resource handle that is passed around to the callback functions.
    dred_gui_resource hResource;
};

struct dred_gui_font
{
    /// A pointer to the context that owns this font.
    dred_gui* pGUI;

    /// The font family.
    char family[DRED_MAX_FONT_FAMILY_LENGTH];

    /// The base size of the font. This is set to the value that was used to create the font in the first place.
    unsigned int size;

    /// The font's weight.
    dred_gui_font_weight weight;

    /// The fon't slant.
    dred_gui_font_slant slant;

    /// The fon't rotation.
    float rotation;

    /// The font's flags. Can be a combination of the following:
    ///   DRED_GUI_FONT_NO_CLEARTYPE
    unsigned int flags;

    /// The internal font. This is created by the rendering backend.
    dred_gui_resource internalFont;
};


struct dred_control
{
    /// A pointer to the context that owns this element. This should never be null for valid elements.
    dred_gui* pGUI;


    /// A pointer to the parent element. This can be null in which case this element is the parent.
    dred_control* pParent;

    /// A pointer to the first child element.
    dred_control* pFirstChild;

    /// A pointer to the last child element.
    dred_control* pLastChild;

    /// A pointer to the next sibling element.
    dred_control* pNextSibling;

    /// A pointer ot the previous sibing element.
    dred_control* pPrevSibling;


    /// A pointer to the next dead element. When an element is deleted during an event handler it is not deleted straight away but
    /// rather at the end of the current batch of event processing. Dead elements are stored in a linked list, with this pointer
    /// acting as the link between items. This will be null if the element is the last in the list, or is not marked as dead. Note
    /// that this should not be used to check if the element is marked as dead - use the IS_CONTROL_DEAD flag instead.
    dred_control* pNextDeadControl;


    /// The type of the element, as a string. This is only every used by the host application, and is intended to be used as way
    /// to selectively perform certain operations on specific types of GUI elements.
    char type[64];


    /// The absolute position of the element on the x axis. A position of 0 is the left side of the surface it is attached to.
    float absolutePosX;

    /// The absolute position of the element on the y axis. A position of 0 is the top of the surface it is attached to.
    float absolutePosY;

    /// The width of the element.
    float width;

    /// The height of the element.
    float height;


    /// The cursor. Defaults to drge_cursor_default.
    dred_cursor_type cursor;

    /// Boolean flags.
    unsigned int flags;

    // The region of the element that's dirty.
    dred_rect dirtyRect;


    /// The function to call when the element's relative position moves.
    dred_gui_on_move_proc onMove;

    /// The function to call when the element's size changes.
    dred_gui_on_size_proc onSize;

    /// The function to call when the mouse enters the given element.
    dred_gui_on_mouse_enter_proc onMouseEnter;

    /// The function to call when the mouse leaves the given element.
    dred_gui_on_mouse_leave_proc onMouseLeave;

    /// The function to call when the mouse is moved while over the element.
    dred_gui_on_mouse_move_proc onMouseMove;

    /// The function to call when a mouse buttonis pressed while over the element.
    dred_gui_on_mouse_button_down_proc onMouseButtonDown;

    /// The function to call when a mouse button is released while over the element.
    dred_gui_on_mouse_button_up_proc onMouseButtonUp;

    /// The function to call when a mouse button is double-clicked while over the element.
    dred_gui_on_mouse_button_dblclick_proc onMouseButtonDblClick;

    /// The function to call when the mouse wheel it turned while over the element.
    dred_gui_on_mouse_wheel_proc onMouseWheel;

    /// The function to call when a key on the keyboard is pressed or auto-repeated.
    dred_gui_on_key_down_proc onKeyDown;

    /// The function to call when a key on the keyboard is released.
    dred_gui_on_key_up_proc onKeyUp;

    /// The function to call when a printable character is pressed or auto-repeated. This would be used for text editing.
    dred_gui_on_printable_key_down_proc onPrintableKeyDown;

    /// The function to call when the paint event is received.
    dred_gui_on_paint_proc onPaint;

    /// The function to call when the element is marked as dirty.
    dred_gui_on_dirty_proc onDirty;

    /// The function to call when a hit test needs to be performed.
    dred_gui_on_hittest_proc onHitTest;

    /// The event handler to call when an element receives the mouse focus.
    dred_gui_on_capture_mouse_proc onCaptureMouse;

    /// The event handler to call when an element loses the mouse focus.
    dred_gui_on_release_mouse_proc onReleaseMouse;

    /// The event handler to call when an element receives the keyboard focus.
    dred_gui_on_capture_keyboard_proc onCaptureKeyboard;

    /// The event handler to call when an element loses the keyboard focus.
    dred_gui_on_release_keyboard_proc onReleaseKeyboard;


    /// The size of the extra data.
    size_t extraDataSize;

    /// A pointer to the extra data.
    uint8_t pExtraData[1];
};

struct dred_gui
{
    // The dred context that owns the GUI system.
    dred_context* pDred;


    /// The paiting context.
    void* pPaintingContext;

    /// The painting callbacks.
    dred_gui_painting_callbacks paintingCallbacks;


    /// The inbound event counter. This is incremented with drgui_begin_inbound_event() and decremented with
    /// drgui_end_inbound_event(). We use this to determine whether or not an inbound event is being processed.
    int inboundEventCounter;

    /// The outbound event counter that we use as the "lock" for outbound events. All outbound events are posted from
    /// inbound events, and all inbound events are already synchronized so we don't need to use a mutex. This is mainly
    /// used as a way to check for erroneous outbound event generation.
    int outboundEventLockCounter;

    /// A pointer to the first element that has been marked as dead. Controls marked as dead are stored as a linked list.
    dred_control* pFirstDeadControl;

    /// A pointer to the element that is sitting directly under the mouse. This is updated on every inbound mouse move event
    /// and is used for determining when a mouse enter/leave event needs to be posted.
    dred_control* pControlUnderMouse;

    /// A pointer to the element with the mouse capture.
    dred_control* pControlWithMouseCapture;

    /// A pointer to the element with the keyboard focus.
    dred_control* pControlWithKeyboardCapture;

    /// A pointer to the element that wants the keyboard focus. If for some reason an element isn't able to immediately
    /// capture the keyboard (such as while in the middle of a release_keyboard event handler) this will be set to that
    /// particular element. This will then be used to capture the keyboard at a later time when it is able.
    dred_control* pControlWantingKeyboardCapture;

    /// The current cursor.
    dred_cursor_type currentCursor;

    /// Boolean flags.
    unsigned int flags;


    /// The global event callback to call when an element is marked as dirty.
    dred_gui_on_dirty_proc onGlobalDirty;

    /// The global event handler to call when an element captures the mouse.
    dred_gui_on_capture_mouse_proc onGlobalCaptureMouse;

    /// The global event handler to call when an element releases the mouse.
    dred_gui_on_release_mouse_proc onGlobalReleaseMouse;

    /// The global event handler to call when an element captures the keyboard.
    dred_gui_on_capture_keyboard_proc onGlobalCaptureKeyboard;

    /// The global event handler to call when an element releases the keyboard.
    dred_gui_on_release_keyboard_proc onGlobalReleaseKeyboard;

    /// The global event handler to call when the system cursor needs to change.
    dred_gui_on_change_cursor_proc onChangeCursor;

    /// The function to call when an element is deleted.
    dred_gui_on_delete_element_proc onDeleteControl;


    /// The function to call when a log message is posted.
    dred_gui_on_log onLog;



    /// A pointer to the top level element that was passed in from the last inbound mouse move event.
    dred_control* pLastMouseMoveTopLevelControl;

    /// The position of the mouse that was passed in from the last inbound mouse move event.
    float lastMouseMovePosX;
    float lastMouseMovePosY;


    // A pointer to the list of dirty elements.
    dred_control** ppDirtyControls;

    // The size of the buffer containing the dirty elements.
    size_t dirtyControlBufferSize;

    // The number of dirty top-level elements.
    size_t dirtyControlCount;

    /// The counter to use when determining whether or not an on_dirty event needs to be posted. This is incremented with
    /// drgui_begin_auto_dirty() and decremented with drgui_end_auto_dirty(). When the counter is decremented and hits
    /// zero, the on_dirty event will be posted.
    unsigned int dirtyCounter;
};



/////////////////////////////////////////////////////////////////
//
// CORE API
//
/////////////////////////////////////////////////////////////////

// Initializes a GUI context.
bool dred_gui_init(dred_gui* pGUI, dred_context* pDred);

/// Deletes a context and everything that it created.
void dred_gui_uninit(dred_gui* pGUI);



/////////////////////////////////////////////////////////////////
// Events

/// Posts a mouse leave inbound event.
///
/// @remarks
///     The intention behind this event is to allow the application to let dr_gui know that the mouse have left the window. Since dr_gui does
///     not have any notion of a window it must rely on the host application to notify it.
void dred_gui_post_inbound_event_mouse_leave(dred_control* pTopLevelControl);

/// Posts a mouse move inbound event.
void dred_gui_post_inbound_event_mouse_move(dred_control* pTopLevelControl, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse button down inbound event.
void dred_gui_post_inbound_event_mouse_button_down(dred_control* pTopLevelControl, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse button up inbound event.
void dred_gui_post_inbound_event_mouse_button_up(dred_control* pTopLevelControl, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse button double-clicked inbound event.
void dred_gui_post_inbound_event_mouse_button_dblclick(dred_control* pTopLevelControl, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a mouse wheel inbound event.
void dred_gui_post_inbound_event_mouse_wheel(dred_control* pTopLevelControl, int mouseButton, int mousePosX, int mousePosY, int stateFlags);

/// Posts a key down inbound event.
void dred_gui_post_inbound_event_key_down(dred_gui* pGUI, dred_key key, int stateFlags);

/// Posts a key up inbound event.
void dred_gui_post_inbound_event_key_up(dred_gui* pGUI, dred_key key, int stateFlags);

/// Posts a printable key down inbound event.
///
/// @remarks
///     The \c character argument should be a UTF-32 code point.
void dred_gui_post_inbound_event_printable_key_down(dred_gui* pGUI, unsigned int character, int stateFlags);


/// Registers the global on_dirty event callback.
///
/// @remarks
///     This is called whenever a region of an element is marked as dirty and allows an application to mark the region of the
///     container window as dirty to trigger an operating system level repaint of the window.
void dred_gui_set_global_on_dirty(dred_gui* pGUI, dred_gui_on_dirty_proc onDirty);

/// Registers the global on_capture_mouse event callback.
///
/// @remarks
///     This is called whenever an element receives an the mouse capture and allows an application to do operating system level
///     mouse captures against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void dred_gui_set_global_on_capture_mouse(dred_gui* pGUI, dred_gui_on_capture_mouse_proc onCaptureMouse);

/// Registers the global on_release_mouse event callback.
///
/// @remarks
///     This is called whenever an element loses an the mouse capture and allows an application to do operating system level
///     mouse releases against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void dred_gui_set_global_on_release_mouse(dred_gui* pGUI, dred_gui_on_release_mouse_proc onReleaseMouse);

/// Registers the global on_capture_keyboard event callback.
///
/// @remarks
///     This is called whenever an element receives an the keyboard capture and allows an application to do an operating system level
///     keyboard focus against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void dred_gui_set_global_on_capture_keyboard(dred_gui* pGUI, dred_gui_on_capture_keyboard_proc onCaptureKeyboard);

/// Registers the global on_release_keyboard event callback.
///
/// @remarks
///     This is called whenever an element loses an the keyboard capture and allows an application to do an operating system level
///     keyboard release against the container window or whatnot.
///     @par
///     The advantage of using a global event callback is that it can be set once at the context level rather than many times
///     at the element level.
void dred_gui_set_global_on_release_keyboard(dred_gui* pGUI, dred_gui_on_capture_keyboard_proc onReleaseKeyboard);

/// Sets the global on_change_cursor event callback.
///
/// @remarks
///     This is called whenever the operating system needs to change the cursor.
void dred_gui_set_global_on_change_cursor(dred_gui* pGUI, dred_gui_on_change_cursor_proc onChangeCursor);

/// Sets the function to call when an element is deleted.
void dred_gui_set_on_delete_element(dred_gui* pGUI, dred_gui_on_delete_element_proc onDeleteControl);


/// Registers the callback to call when a log message is posted.
void dred_gui_set_on_log(dred_gui* pGUI, dred_gui_on_log onLog);




/////////////////////////////////////////////////////////////////
// Controls

/// Creates an element.
dred_control* dred_control_create(dred_context* pDred, dred_control* pParent, const char* type, size_t extraDataSize);

/// Deletes and element.
void dred_control_delete(dred_control* pControl);


// Retrieves the dred context that owns the given control.
dred_context* dred_control_get_gui(dred_control* pControl);


/// Retrieves the size of the extra data of the given element, in bytes.
size_t dred_control_get_extra_data_size(dred_control* pControl);

/// Retrieves a pointer to the extra data of the given element.
void* dred_control_get_extra_data(dred_control* pControl);


/// Sets the type of the element.
///
/// The type name cannot be more than 63 characters in length.
bool dred_control_set_type(dred_control* pControl, const char* type);

/// Retrieves the type fo the element.
const char* dred_control_get_type(dred_control* pControl);

/// Determines whether or not the given element is of the given type.
bool dred_control_is_of_type(dred_control* pControl, const char* type);
bool dred_is_control_type_of_type(const char* type, const char* base);


/// Hides the given element.
void dred_control_hide(dred_control *pControl);

/// Shows the given element.
void dred_control_show(dred_control* pControl);

/// Determines whether or not the element is marked as visible.
///
/// @remarks
///     This is a direct accessor for the internal visible flag of the element and is not recursive. Thus, if this element is
///     marked as visible, but it's parent is invisible, it will still return true. Use dred_control_is_visible_recursive() to do
///     a recursive visibility check.
bool dred_control_is_visible(const dred_control* pControl);

/// Recursively determines whether or not the element is marked as visible.
bool dred_control_is_visible_recursive(const dred_control* pControl);


/// Disables clipping against the parent for the given element.
void dred_control_disable_clipping(dred_control* pControl);

/// Enables clipping against the parent for the given element.
void dred_control_enable_clipping(dred_control* pControl);

/// Determines whether or not clipping is enabled for the given element.
bool dred_control_is_clipping_enabled(const dred_control* pControl);


/// Sets the element that should receive all future mouse related events.
///
/// @remarks
///     Release the mouse capture with drgui_release_mosue().
void dred_gui_capture_mouse(dred_control* pControl);
void dred_control_capture_mouse(dred_control* pControl) { dred_gui_capture_mouse(pControl); }

/// Releases the mouse capture.
void dred_gui_release_mouse(dred_gui* pGUI);

/// Releases the mouse capture without posting the global-scoped event. Should only be used in very specific cases, usually in combination with awkward interop with the window system.
void dred_gui_release_mouse_no_global_notify(dred_gui* pGUI);

/// Retrieves a pointer to the element with the mouse capture.
dred_control* dred_gui_get_element_with_mouse_capture(dred_gui* pGUI);

/// Determines whether or not the given element has the mouse capture.
bool dred_control_has_mouse_capture(dred_control* pControl);


/// Sets the element that should receive all future keyboard related events.
///
/// @remarks
///     Releases the keyboard capture with dred_gui_release_keyboard().
void dred_gui_capture_keyboard(dred_control* pControl);
void dred_control_capture_keyboard(dred_control* pControl) { dred_gui_capture_keyboard(pControl); }

/// Releases the keyboard capture.
void dred_gui_release_keyboard(dred_gui* pGUI);

/// Releases the keyboard capture without posting the global-scoped event. Should only be used in very specific cases, usually in combination with awkward interop with the window system.
void dred_gui_release_keyboard_no_global_notify(dred_gui* pGUI);

/// Retrieves a pointer to the element with the keyboard capture.
dred_control* dred_gui_get_element_with_keyboard_capture(dred_gui* pGUI);

/// Determines whether or not the given element has the keyboard capture.
bool dred_control_has_keyboard_capture(dred_control* pControl);


/// Sets the cursor to use when the mouse enters the given GUI element.
void dred_control_set_cursor(dred_control* pControl, dred_cursor_type cursor);

/// Retrieves the cursor to use when the mouse enters the given GUI element.
dred_cursor_type dred_control_get_cursor(dred_control* pControl);

// Helper function for showing a popup menu relative to the given control.
void dred_control_show_popup_menu(dred_control* pControl, dred_menu* pMenu, int relativePosX, int relativePosY);


//// Events ////

/// Registers the on_move event callback.
void dred_control_set_on_move(dred_control* pControl, dred_gui_on_move_proc callback);

/// Registers the on_size event callback.
void dred_control_set_on_size(dred_control* pControl, dred_gui_on_size_proc callback);

/// Registers the on_mouse_enter event callback.
void dred_control_set_on_mouse_enter(dred_control* pControl, dred_gui_on_mouse_enter_proc callback);

/// Registers the on_mouse_leave event callback.
void dred_control_set_on_mouse_leave(dred_control* pControl, dred_gui_on_mouse_leave_proc callback);

/// Registers the on_mouse_move event callback.
void dred_control_set_on_mouse_move(dred_control* pControl, dred_gui_on_mouse_move_proc callback);

/// Registers the on_mouse_button_down event callback.
void dred_control_set_on_mouse_button_down(dred_control* pControl, dred_gui_on_mouse_button_down_proc callback);

/// Registers the on_mouse_button_up event callback.
void dred_control_set_on_mouse_button_up(dred_control* pControl, dred_gui_on_mouse_button_up_proc callback);

/// Registers the on_mouse_button_down event callback.
void dred_control_set_on_mouse_button_dblclick(dred_control* pControl, dred_gui_on_mouse_button_dblclick_proc callback);

/// Registers the on_mouse_wheel event callback.
void dred_control_set_on_mouse_wheel(dred_control* pControl, dred_gui_on_mouse_wheel_proc callback);

/// Registers the on_key_down event callback.
void dred_control_set_on_key_down(dred_control* pControl, dred_gui_on_key_down_proc callback);

/// Registers the on_key_up event callback.
void dred_control_set_on_key_up(dred_control* pControl, dred_gui_on_key_up_proc callback);

/// Registers the on_printable_key_down event callback.
void dred_control_set_on_printable_key_down(dred_control* pControl, dred_gui_on_printable_key_down_proc callback);

/// Registers the on_paint event callback.
void dred_control_set_on_paint(dred_control* pControl, dred_gui_on_paint_proc callback);

/// Registers the on_dirty event callback.
void dred_control_set_on_dirty(dred_control* pControl, dred_gui_on_dirty_proc callback);

/// Registers the on_hittest event callback.
void dred_control_set_on_hittest(dred_control* pControl, dred_gui_on_hittest_proc callback);

/// Registers the on_capture_mouse event callback.
void dred_control_set_on_capture_mouse(dred_control* pControl, dred_gui_on_capture_mouse_proc callback);

/// Registers the on_release_mouse event callback.
void dred_control_set_on_release_mouse(dred_control* pControl, dred_gui_on_release_mouse_proc callback);

/// Registers the on_capture_keyboard event callback.
void dred_control_set_on_capture_keyboard(dred_control* pControl, dred_gui_on_capture_keyboard_proc callback);

/// Registers the on_release_keyboard event callback.
void dred_control_set_on_release_keyboard(dred_control* pControl, dred_gui_on_release_keyboard_proc callback);



//// Containment and Hit Detection ////

/// Determines whether or not the given point is inside the bounds of the given element.
///
/// @remarks
///     This only checks if the point is inside the bounds of the element and does not take hit testing into account. This difference
///     with this one and dred_control_is_point_inside() is that the latter will use hit testing.
bool dred_control_is_point_inside_bounds(const dred_control* pControl, float absolutePosX, float absolutePosY);

/// Determines whether or not the given point is inside the given element.
///
/// @remarks
///     This will use hit testing to determine whether or not the point is inside the element.
bool dred_control_is_point_inside(dred_control* pControl, float absolutePosX, float absolutePosY);

/// Finds the element under the given point taking mouse pass-through and hit testing into account.
dred_control* dred_gui_find_control_under_point(dred_control* pTopLevelControl, float absolutePosX, float absolutePosY);

/// Determines whether or not the given element is currently sitting directly under the mouse.
bool dred_control_is_under_mouse(dred_control* pTopLevelControl);



//// Hierarchy ////

// Retrieves the parent of the given element.
dred_control* dred_control_get_parent(dred_control* pChildControl);

/// Detaches the given element from it's parent.
void dred_control_detach(dred_control* pChildControl);

/// Attaches the given element as a child of the given parent element, and appends it to the end of the children list.
void dred_control_append(dred_control* pChildControl, dred_control* pParentControl);

/// Attaches the given element as a child of the given parent element, and prepends it to the end of the children list.
void dred_control_prepend(dred_control* pChildControl, dred_control* pParentControl);

/// Appends the given element to the given sibling.
void dred_control_append_sibling(dred_control* pControlToAppend, dred_control* pControlToAppendTo);

/// Prepends the given element to the given sibling.
void dred_control_prepend_sibling(dred_control* pControlToPrepend, dred_control* pControlToPrependTo);

/// Retrieves a pointer to the given element's top-level ancestor.
///
/// @remarks
///     If pControl is the top level element, the return value will be pControl.
dred_control* dred_control_find_top_level_control(dred_control* pControl);

/// Determines whether or not the given element is the parent of the other.
///
/// @remarks
///     This is not recursive. Use dred_control_is_ancestor() to do a recursive traversal.
bool dred_control_is_parent(dred_control* pParentControl, dred_control* pChildControl);

/// Determines whether or not the given element is a child of the other.
///
/// @remarks
///     This is not recursive. Use dred_control_is_descendant() to do a recursive traversal.
bool dred_control_is_child(dred_control* pChildControl, dred_control* pParentControl);

/// Determines whether or not the given element is an ancestor of the other.
bool dred_control_is_ancestor(dred_control* pAncestorControl, dred_control* pChildControl);

/// Determines whether or not the given element is a descendant of the other.
bool dred_control_is_descendant(dred_control* pChildControl, dred_control* pAncestorControl);

/// Determines whether or not the given element is itself or a descendant.
bool dred_control_is_self_or_ancestor(dred_control* pAncestorControl, dred_control* pChildControl);

/// Determines whether or not the given element is itself or a descendant.
bool dred_control_is_self_or_descendant(dred_control* pChildControl, dred_control* pAncestorControl);



//// Layout ////

/// Sets the absolute position of the given element.
void dred_control_set_absolute_position(dred_control* pControl, float positionX, float positionY);

/// Retrieves the absolute position of the given element.
void dred_control_get_absolute_position(const dred_control* pControl, float* positionXOut, float* positionYOut);
float dred_control_get_absolute_position_x(const dred_control* pControl);
float dred_control_get_absolute_position_y(const dred_control* pControl);


/// Sets the relative position of the given element.
void dred_control_set_relative_position(dred_control* pControl, float relativePosX, float relativePosY);

/// Retrieves the relative position of the given element.
void dred_control_get_relative_position(const dred_control* pControl, float* relativePosXOut, float* relativePosYOut);
float dred_control_get_relative_position_x(const dred_control* pControl);
float dred_control_get_relative_position_y(const dred_control* pControl);


/// Sets the size of the given element.
void dred_control_set_size(dred_control* pControl, float width, float height);

/// Retrieves the size of the given element.
void dred_control_get_size(const dred_control* pControl, float* widthOut, float* heightOut);
float dred_control_get_width(const dred_control* pControl);
float dred_control_get_height(const dred_control* pControl);



/// Retrieves the absolute rectangle for the given element.
dred_rect dred_control_get_absolute_rect(const dred_control* pControl);

/// Retrieves the relative rectangle for the given element.
dred_rect dred_control_get_relative_rect(const dred_control* pControl);

/// Retrieves the local rectangle for the given element.
///
/// @remarks
///     The local rectangle is equivalent to drgui_make_rect(0, 0, dred_control_get_width(pControl), dred_control_get_height(pControl));
dred_rect dred_control_get_local_rect(const dred_control* pControl);



//// Painting ////

/// Registers the custom painting callbacks.
///
/// @remarks
///     This can only be called once, so it should always be done after initialization. This will fail if called
///     more than once.
bool dred_gui_register_painting_callbacks(dred_gui* pGUI, void* pPaintingContext, dred_gui_painting_callbacks callbacks);


/// Performs a recursive traversal of all visible elements in the given rectangle.
///
/// @param pParentControl [in] A pointer to the element to iterate.
///
/// @remarks
///     pParentControl will be included in the iteration is it is within the rectangle.
///     @par
///     The rectangle should be relative to pParentControl.
///     @par
///     The iteration callback function takes a pointer to a rectangle structure that represents the visible portion of the
///     element. This pointer can be modified by the callback to create an adjusted rectangle which can be used for clipping.
bool dred_control_iterate_visible_elements(dred_control* pParentControl, dred_rect relativeRect, dred_gui_visible_iteration_proc callback, void* pUserData);


/// Disable's automatic dirtying of elements.
void dred_gui_disable_auto_dirty(dred_gui* pGUI);

/// Enable's automatic dirtying of elements.
void dred_gui_enable_auto_dirty(dred_gui* pGUI);

/// Determines whether or not automatic dirtying is enabled.
bool dred_gui_is_auto_dirty_enabled(dred_gui* pGUI);


/// Begins accumulating a dirty rectangle.
///
/// Returns a pointer to the top level element that was made dirty.
dred_control* dred_control_begin_dirty(dred_control* pControl);

/// Ends accumulating a dirty rectangle, and requests a redraw from the backend if the counter reaches zero.
void dred_control_end_dirty(dred_control* pControl);

/// Marks a region of the given element as dirty.
///
/// @remarks
///     This will not redraw the element immediately, but instead post a paint event.
void dred_control_dirty(dred_control* pControl, dred_rect relativeRect);


/// Draws the given element.
///
/// @remarks
///     Do not call this on one element, then again on it's children. Any children that fall inside the specified
///     rectangle will also be redrawn.
///     @par
///     This will call painting event handlers which will give the application time to do custom drawing.
///     @par
///     When using easy_draw to do drawing, pPaintData must be set to a pointer to the relevant easydraw_surface object.
void dred_control_draw(dred_control* pControl, dred_rect relativeRect, void* pPaintData);

/// Retrieves the current clipping rectangle.
void dred_control_get_clip(dred_control* pControl, dred_rect* pRelativeRect, void* pPaintData);

/// Sets the clipping rectangle to apply to all future draw operations on this element.
void dred_control_set_clip(dred_control* pControl, dred_rect relativeRect, void* pPaintData);

/// Draws a rectangle on the given element.
void dred_control_draw_rect(dred_control* pControl, dred_rect relativeRect, dred_color color, void* pPaintData);

/// Draws the outline of a rectangle on the given element.
void dred_control_draw_rect_outline(dred_control* pControl, dred_rect relativeRect, dred_color color, float outlineWidth, void* pPaintData);

/// Draws a filled rectangle with an outline on the given element.
void dred_control_draw_rect_with_outline(dred_control* pControl, dred_rect relativeRect, dred_color color, float outlineWidth, dred_color outlineColor, void* pPaintData);

/// Draws a rectangle with rounded corners on the given element.
void dred_control_draw_round_rect(dred_control* pControl, dred_rect relativeRect, dred_color color, float radius, void* pPaintData);

/// Draws the outline of a rectangle with rounded corners on the given element.
void dred_control_draw_round_rect_outline(dred_control* pControl, dred_rect relativeRect, dred_color color, float radius, float outlineWidth, void* pPaintData);

/// Draws a filled rectangle and it's outline with rounded corners on the given element.
void dred_control_draw_round_rect_with_outline(dred_control* pControl, dred_rect relativeRect, dred_color color, float radius, float outlineWidth, dred_color outlineColor, void* pPaintData);

/// Draws a run of text on the given element.
///
/// @remarks
///     This does not do any complex formatting like multiple lines and whatnot. Complex formatting can be achieved with multiple
///     calls to this function.
///     @par
///     \c textSizeInBytes can be -1 in which case the text string is treated as null terminated.
void dred_control_draw_text(dred_control* pControl, dred_gui_font* pFont, const char* text, int textLengthInBytes, float posX, float posY, dred_color color, dred_color backgroundColor, void* pPaintData);

/// Draws an image.
void dred_control_draw_image(dred_control* pControl, dred_gui_image* pImage, dred_gui_draw_image_args* pArgs, void* pPaintData);


/// Creates a font resource.
dred_gui_font* dred_gui_create_font(dred_gui* pGUI, const char* family, unsigned int size, dred_gui_font_weight weight, dred_gui_font_slant slant, float rotation, unsigned int flags);

/// Deletes a font resource.
void dred_gui_delete_font(dred_gui_font* pFont);

/// Retrieves the metrics of the given font.
bool dred_gui_get_font_metrics(dred_gui_font* pFont, dred_gui_font_metrics* pMetricsOut);

/// Retrieves the metrics of the glyph for the given character when rendered with the given font.
bool dred_gui_get_glyph_metrics(dred_gui_font* pFont, unsigned int utf32, dred_glyph_metrics* pMetricsOut);

/// Retrieves the dimensions of the given string when drawn with the given font.
///
/// @remarks
///     When the length of the text is 0, the width will be set to 0 and the height will be set to the line height.
bool dred_gui_measure_string(dred_gui_font* pFont, const char* text, size_t textLengthInBytes, float* pWidthOut, float* pHeightOut);

/// Retrieves the position to place a text cursor based on the given point for the given string when drawn with the given font.
bool dred_gui_get_text_cursor_position_from_point(dred_gui_font* pFont, const char* text, size_t textSizeInBytes, float maxWidth, float inputPosX, float* pTextCursorPosXOut, size_t* pCharacterIndexOut);

/// Retrieves the position to palce a text cursor based on the character at the given index for the given string when drawn with the given font.
bool dred_gui_get_text_cursor_position_from_char(dred_gui_font* pFont, const char* text, size_t characterIndex, float* pTextCursorPosXOut);



/// Creates an image that can be passed to dred_control_draw_image().
///
/// @remarks
///     The dimensions and format of an image are immutable. If these need to change, then the image needs to be deleted and re-created.
///     @par
///     If pData is NULL, the default image data is undefined.
///     @par
///     If stride is set to 0, it is assumed to be tightly packed.
///     @par
///     Use dred_gui_map_image_data() and dred_gui_unmap_image_data() to update or retrieve image data.
dred_gui_image* dred_gui_create_image(dred_gui* pGUI, unsigned int width, unsigned int height, dred_gui_image_format format, unsigned int stride, const void* pData);

/// Deletes the given image.
void dred_gui_delete_image(dred_gui_image* pImage);

/// Retrieves the size of the given image.
void dred_gui_get_image_size(dred_gui_image* pImage, unsigned int* pWidthOut, unsigned int* pHeightOut);

/// Retrieves the optimal image format for the given context.
dred_gui_image_format dred_gui_get_optimal_image_format(dred_gui* pGUI);

/// Retrieves a pointer to a buffer representing the given image's data.
///
/// Call dred_gui_unmap_image_data() when you are done with this function.
///
/// Use this function to access an image's data. The returned pointer does not necessarilly point to the image's actual data, so when
/// writing to this pointer, nothing is actually updated until dred_gui_unmap_image_data() is called.
///
/// The returned data will contain the image data at the time of the mapping.
void* dred_gui_map_image_data(dred_gui_image* pImage, unsigned int accessFlags);

/// Unmaps the given image data.
void dred_gui_unmap_image_data(dred_gui_image* pImage);



/////////////////////////////////////////////////////////////////
//
// HIGH-LEVEL API
//
/////////////////////////////////////////////////////////////////

//// Hit Testing and Layout ////

/// An on_size event callback that resizes every child element to that of the parent.
void dred_control_on_size_fit_children_to_parent(dred_control* pControl, float newWidth, float newHeight);

/// An on_hit_test event callback that can be used to always fail the mouse hit test.
bool dred_control_pass_through_hit_test(dred_control* pControl, float mousePosX, float mousePosY);


//// Painting ////

/// Draws a border around the given element.
void dred_control_draw_border(dred_control* pControl, float borderWidth, dred_color color, void* pUserData);



/////////////////////////////////////////////////////////////////
//
// UTILITY API
//
/////////////////////////////////////////////////////////////////

/// Creates a color object from a set of RGBA color components.
dred_color drgui_rgba(uint8_t r, uint8_t g, uint8_t b, uint8_t a);

/// Creates a color object from a set of RGB color components.
dred_color drgui_rgb(uint8_t r, uint8_t g, uint8_t b);

/// Clamps the given rectangle to another.
dred_rect drgui_clamp_rect(dred_rect rect, dred_rect other);

/// Clamps the given rectangle to the given element and returns whether or not any of it is contained within the element's rectangle.
bool drgui_clamp_rect_to_element(const dred_control* pControl, dred_rect* pRelativeRect);

/// Converts the given rectangle from absolute to relative to the given element.
dred_rect drgui_make_rect_relative(const dred_control* pControl, dred_rect* pRect);

/// Converts the given rectangle from relative to absolute based on the given element.
dred_rect drgui_make_rect_absolute(const dred_control* pControl, dred_rect* pRect);

/// Converts the given point from absolute to relative to the given element.
void drgui_make_point_relative(const dred_control* pControl, float* positionX, float* positionY);

/// Converts the given point from relative to absolute based on the given element.
void drgui_make_point_absolute(const dred_control* pControl, float* positionX, float* positionY);

/// Creates a dred_rect object.
dred_rect drgui_make_rect(float left, float top, float right, float bottom);

/// Creates an inside-out rectangle.
///
/// @remarks
///     An inside our rectangle is a negative-dimension rectangle with each edge at the extreme edges. The left edge will be at the
///     right-most side and the right edge will be at the left-most side. The same applies for the top and bottom edges.
dred_rect drgui_make_inside_out_rect();

/// Expands the given rectangle on all sides by the given amount.
///
/// @remarks
///     This will increase the width and height of the rectangle by <amount> x 2.
///     @par
///     The growth amount can be negative, in which case it will be shrunk. Note that this does not do any checking to ensure the rectangle
///     contains positive dimensions after a shrink.
dred_rect drgui_grow_rect(dred_rect rect, float amount);

/// Scales the given rectangle.
///
/// @param scaleX [in] The scale to apply to <left> and <right>
/// @param scaleY [in] The scale to apply to <top> and <bottom>
///
/// @remarks
///     This will modify the <left> and <top> properties which means the rectangle will change position. To adjust only the size, scale the
///     rectangle manually.
dred_rect drgui_scale_rect(dred_rect rect, float scaleX, float scaleY);

/// Offsets the given rectangle.
dred_rect drgui_offset_rect(dred_rect rect, float offsetX, float offsetY);

/// Creates a rectangle that contains both of the given rectangles.
dred_rect dred_rect_union(dred_rect rect0, dred_rect rect1);

/// Determines whether or not the given rectangle contains the given point.
///
/// @remarks
///     An important not here is that if the position is sitting on the right or bottom border, false will be returned. If, however, the point
///     is sitting on the left or top border, true will be returned. The reason for this is that elements may sit exactly side-by-side with
///     each other, and if we use this function to determine if a point is contained within an element (which we do), we would end up having
///     this return true for both elements, which we don't want.
bool dred_rect_contains_point(dred_rect rect, float posX, float posY);

/// Determines whether or not two rectangles are equal.
bool dred_rect_equal(dred_rect rect0, dred_rect rect1);

/// Determines whether or not the given rectangle has any volume (width and height > 0).
bool dred_rect_has_volume(dred_rect rect);



/////////////////////////////////////////////////////////////////
//
// DR_2D-SPECIFIC API
//
/////////////////////////////////////////////////////////////////
#ifndef DRED_GUI_NO_DR_2D

/// A covenience function for creating a new context and registering the easy_draw painting callbacks.
///
/// @remarks
///     This is equivalent to drgui_create_context() followed by drgui_register_dr_2d_callbacks().
bool dred_gui_init_dr_2d(dred_gui* pGUI, dred_context* pDred, dr2d_context* pDrawingContext);

/// Registers the drawing callbacks for use with easy_draw.
///
/// @remarks
///     The user data of each callback is assumed to be a pointer to an easydraw_surface object.
void drgui_register_dr_2d_callbacks(dred_gui* pGUI, dr2d_context* pDrawingContext);

#endif
