// Copyright (C) 2019 David Reid. See included LICENSE file.

// QUICK NOTES
//
// General
// - dr_gui is a low-level GUI system that works on generic objects referred to as "elements".
// - An element is the most basic unit in dr_gui. It contains basic information about it's layout and hierarchy.
// - Controls can be used as the building blocks for more complex controls such as list boxes and scrollbars.
// - The layout of elements use floats instead of integers. The rationale for this is that it makes it easier to do certain
//   layout arithmetic. For example, if you want to evenly distribute 3 elements across a fixed area, the integer based
//   arithmetic can cause rounding errors which cause the elements to not sit flush against the area. By using float-based
//   arithmetic we can avoid that particular issue.
//
// Hierarchy
// - An element can have a parent and any number of children. If an element does not have a parent, it is referred to as the
//   top-level element.
// - When an element is deleted, it's children will be deleted as well.
// - Top-level elements do not have siblings.
//
// Event Handling
// - The application must notify dr_gui of application-generated events such as key strokes and mouse movements. These are
//   referred to as inbound events. An event that is generated by dr_gui are referred to as outbound events.
// - Inbound events are used to generate outbound events. For example, a mouse-move inbound event will generate an outbound
//   mouse-move event, and perhaps a mouse leave/enter pair.
// - Outbound events are posted and handled immediately. A call to dred_gui_post_inbound_event_*() will not return until all of
//   the outbound events it generates have been handled.
// - Inbound events are not thread safe, however an application is free to post an inbound event from any thread so long as
//   it does it's own synchronization.
// - Inbound events will typically specify the relevant top-level element and let dr_gui do the relevant processing required
//   to generate the appropriate outbound events. For example, the mouse-move event will be specified with respect to the top-
//   level element, but dr_gui will determine the exact child element that the mouse moved on and thus should receive the
//   relevant outbound mouse-move event.
// - There are some special events that are handled differently to normal events. The best example is the paint events. The
//   paint event is only called from dred_control_draw().
// - Key press/release events are only ever posted to the element that has the keyboard capture/focus which is set with
//   dred_gui_capture_keyboard(). Thus, when posting an inbound key event, a top-level element is not required when posting
//   those events. The relevant context is still required, however.
//
// Global Outbound Event Handling
// - At times dr_gui will need to notify the host application in order for certain functionality to work properly. For example.
//   when the mouse is captured it won't work 100% correct unless the host application has a chance to capture the mouse against
//   the container window. Because dr_gui has no notion of a window system it relies on the host application to handle this
//   properly.
// - A global outbound event handler should be implemented for each of the following events:
//   - on_dirty: Called when a region of an element is marked as dirty and needs to be redrawn. The application will want to
//     invalidate the container window to trigger an operating system redraw. Set this with dred_gui_set_global_on_dirty().
//   - on_capture_mouse: Called when the mouse is captured and gives the application the opportunity to capture the mouse against
//     the container window at the operating system level. Set with dred_gui_set_global_on_capture_mouse().
//   - on_release_mouse: Called when the mouse is released. The opposite of on_capture_mouse.
//   - on_capture_keyboard: Called when an element is given the keyboard focus and gives the application the opportunity to
//     apply the keyboard focus to the container window. Set with dred_gui_set_global_on_capture_keyboard().
//   - on_release_keyboard: Called when an element loses the keyboard focus. The opposite of on_capture_keyboard.
//   - on_change_cursor: Called when the current cursor needs to be changed as a result of the mouse moving over a new element.
//
// Layout
// - An element's data structure does not store it's relative position but instead stores it's absolute position. The rationale
//   for this is that storing it as relative complicates absolute positioning calculations because it would need to do a recursive
//   traversal of the element's ancestors.
// - Child elements can be scaled by setting an element's inner scale. The inner scale does not scale the element itself - only
//   it's children.
// - When an element is drawn, everything is scaled by it's inner scale. For example, if the inner scale is 2x and a 100x100 quad
//   is drawn, the quad will be scaled to 200x200. An exception to this rule is fonts, which are never scaled. This 0s because
//   text is always drawn based on the size of the font.
// - Applications should only need to work on unscaled coordinates. That is, an application should never need to worry about
//   manual scaling, except for fonts. When positioning and sizing child elements, they should be done based on unscaled
//   coordinates.
// - Use the inner scale system for DPI awareness.
// - The inner scale is applied recursively. That is, if a top level element has it's inner scale set to 2x and one of it's
//   children has an inner scale of 2x, the actual inner scale of the child element will be 4x.
//
//
// Drawing/Painting
// - Drawing is one of the more complex parts of the GUI because it can be a bit unintuitive regarding exactly when an element
//   is drawn and when a drawing function is allowed to be called.
// - To draw an element, call dred_control_draw(). This takes a pointer to the element to draw and the rectangle region that should
//   be redrawn. Any children that fall inside the specified rectangle region will be redrawn as well. You do not want to call
//   dred_control_draw() on a parent element and then again on it's children because dr_gui will do that automatically.
// - dred_control_draw() does not draw anything directly, but rather calls painting callback routines which is where the actual
//   drawing takes place.
// - Sometimes an application will need to be told when a region of an element is dirty and needs redrawing. An example is
//   event-driven, non real-time applications such as normal desktop applications. To mark an element as dirty, you call the
//   dred_control_dirty() function which takes the element that is dirty, and the rectangle region that needs to be redrawn. This
//   does not redraw the element immediately, but instead posts an on_dirty event for the application. Marking regions as dirty
//   is not strictly required, but you should prefer it for event-driven applications that require painting operations to be
//   performed at specific times (such as inside Win32's WM_PAINT messages).
// - Some operations will cause a region of an element to become dirty - such as when it is resized. dr_gui will
//   automatically mark the relevant regions as dirty which in turn will cause a paint message to be posted. If this is not
//   required, it can be disabled with dred_gui_disable_auto_dirty(). You may want to disable automatic dirtying if you are
//   running a real-time application like a game which would redraw the entire GUI every frame anyway and thus not require
//   handling of the paint message.
// - Real-time application guidelines (games, etc.):
//   - dred_gui_disable_auto_dirty()
//   - dred_control_draw(pTopLevelControl, 0, 0, viewportWidth, viewportHeight) at the end of every frame after your main loop.


//
// EXAMPLES
//
// Basic Drawing:
//
// dred_control_draw(pTopLevelControl, 0, 0, dred_control_get_width(pTopLevelControl), dred_control_get_height(pTopLevelControl));
//
// -------------------------
//
// Event-Driven Drawing (Win32):
//
// void my_global_on_dirty_win32(dred_control* pControl, dred_rect relativeRect) {
//     dred_rect absoluteRect = relativeRect;
//     dred_make_rect_absolute(pControl, &absoluteRect);
//
//     RECT rect;
//     rect.left   = absoluteRect.left;
//     rect.top    = absoluteRect.top;
//     rect.right  = absoluteRect.right;
//     rect.height = absoluteRect.bottom;
//     InvalidateRect((HWND)dred_control_get_user_data(dred_control_find_top_level_control(pControl)), &rect, FALSE);
// }
//
// ...
//
// LRESULT CALLBACK MyWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
//     ...
//     dred_control* pTopLevelControl = (dred_control*)GetWindowLongPtr(hWnd, 0);
//     if (pTopLevelControl != NULL) {
//         switch (msg) {
//             ...
//             case WM_PAINT:
//             {
//                 RECT rect;
//                 if (GetUpdateRect(hWnd, &rect, FALSE)) {
//                     dred_control_draw(pTopLevelControl, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
//                 }
//
//                 break;
//             }
//             ...
//         }
//     }
//     ...
// }
//

#ifndef DRED_MAX_FONT_FAMILY_LENGTH
#define DRED_MAX_FONT_FAMILY_LENGTH  128
#endif

typedef struct dred_gui dred_gui;
typedef struct dred_control dred_control;
typedef struct dred_rect dred_rect;
typedef struct dred_gui_painting_callbacks dred_gui_painting_callbacks;
typedef struct dred_gui_font dred_gui_font;
typedef struct dred_gui_image dred_gui_image;


// Casts a pointer to any structure to a dred_control*. Note that this will only work if the dred_control object
// is at the first byte of the structure.
#define DRED_CONTROL(a) ((dred_control*)(a))

/// Structure representing a rectangle.
struct dred_rect
{
    float left;
    float top;
    float right;
    float bottom;
};

typedef struct
{
    dtk_color bgColor;
    dtk_color fgColor;
    dtk_font* pFont;
} dred_text_style;

typedef struct
{
    /// The destination position on the x axis. This is ignored if the DR2D_IMAGE_ALIGN_CENTER option is set.
    float dstX;

    /// The destination position on the y axis. This is ignored if the DR2D_IMAGE_ALIGN_CENTER option is set.
    float dstY;

    /// The destination width.
    float dstWidth;

    /// The destination height.
    float dstHeight;


    /// The source offset on the x axis.
    float srcX;

    /// The source offset on the y axis.
    float srcY;

    /// The source width.
    float srcWidth;

    /// The source height.
    float srcHeight;


    /// The position of the destination's bounds on the x axis.
    float dstBoundsX;

    /// The position of the destination's bounds on the y axis.
    float dstBoundsY;

    /// The width of the destination's bounds.
    float dstBoundsWidth;

    /// The height of the destination's bounds.
    float dstBoundsHeight;


    /// The foreground tint color. This is not applied to the background color, and the alpha component is ignored.
    dtk_color foregroundTint;

    /// The background color. Only used if the DR2D_IMAGE_DRAW_BACKGROUND option is set.
    dtk_color backgroundColor;

    /// The bounds color. This color is used for the region of the bounds that sit on the outside of the destination rectangle. This will
    /// usually be set to the same value as backgroundColor, but it could also be used to draw a border around the image.
    dtk_color boundsColor;


    /// Flags for controlling how the image should be drawn.
    unsigned int options;

} dred_gui_draw_image_args;


#define DRED_GUI_IMAGE_DRAW_BOUNDS         (1 << 2)
#define DRED_GUI_IMAGE_CLIP_BOUNDS         (1 << 3)        //< Clips the image to the bounds
#define DRED_GUI_IMAGE_ALIGN_CENTER        (1 << 4)

#define DRED_GUI_READ                      (1 << 0)
#define DRED_GUI_WRITE                     (1 << 1)

#define DRED_GUI_FONT_NO_CLEARTYPE         (1 << 0)


typedef void (* dred_gui_on_move_proc)                 (dred_control* pControl, float newRelativePosX, float newRelativePosY);
typedef void (* dred_gui_on_size_proc)                 (dred_control* pControl, float newWidth, float newHeight);
typedef void (* dred_gui_on_mouse_enter_proc)          (dred_control* pControl);
typedef void (* dred_gui_on_mouse_leave_proc)          (dred_control* pControl);
typedef void (* dred_gui_on_mouse_move_proc)           (dred_control* pControl, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_mouse_button_down_proc)    (dred_control* pControl, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_mouse_button_up_proc)      (dred_control* pControl, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_mouse_button_dblclick_proc)(dred_control* pControl, int mouseButton, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_mouse_wheel_proc)          (dred_control* pControl, int delta, int relativeMousePosX, int relativeMousePosY, int stateFlags);
typedef void (* dred_gui_on_key_down_proc)             (dred_control* pControl, dtk_key key, int stateFlags);
typedef void (* dred_gui_on_key_up_proc)               (dred_control* pControl, dtk_key key, int stateFlags);
typedef void (* dred_gui_on_printable_key_down_proc)   (dred_control* pControl, unsigned int character, int stateFlags);
typedef void (* dred_gui_on_paint_proc)                (dred_control* pControl, dred_rect relativeRect, dtk_surface* pSurface);
typedef void (* dred_gui_on_dirty_proc)                (dred_control* pControl, dred_rect relativeRect);
typedef dtk_bool32 (* dred_gui_on_hittest_proc)              (dred_control* pControl, float relativePosX, float relativePosY);
typedef void (* dred_gui_on_capture_mouse_proc)        (dred_control* pControl);
typedef void (* dred_gui_on_release_mouse_proc)        (dred_control* pControl);
typedef void (* dred_gui_on_capture_keyboard_proc)     (dred_control* pControl, dtk_control* pPrevCapturedControl);
typedef void (* dred_gui_on_release_keyboard_proc)     (dred_control* pControl, dtk_control* pNewCapturedControl);
typedef void (* dred_gui_on_change_cursor_proc)        (dred_control* pControl, dtk_system_cursor_type cursor);
typedef void (* dred_gui_on_delete_element_proc)       (dred_control* pControl);
typedef void (* dred_gui_on_log)                       (dred_gui* pGUI, const char* message);

typedef void (* dred_gui_set_clip_proc)          (dred_rect relativeRect, dtk_surface* pSurface);
typedef void (* dred_gui_get_clip_proc)          (dred_rect* pRectOut, dtk_surface* pSurface);
typedef void (* dred_gui_draw_rect_proc)         (dred_rect relativeRect, dtk_color color, dtk_surface* pSurface);
typedef void (* dred_gui_draw_rect_outline_proc) (dred_rect relativeRect, dtk_color color, float outlineWidth, dtk_surface* pSurface);
typedef void (* dred_gui_draw_text_proc)         (dtk_font* pFont, float scale, const char* text, int textLengthInBytes, float posX, float posY, dtk_color color, dtk_color backgroundColor, dtk_surface* pSurface);

typedef dtk_bool32 (* dred_gui_visible_iteration_proc)(dred_control* pControl, dred_rect *pRelativeRect, void* pUserData);

// Structure containing callbacks for painting routines.
struct dred_gui_painting_callbacks
{
    dred_gui_set_clip_proc          setClip;
    dred_gui_get_clip_proc          getClip;
    dred_gui_draw_rect_proc         drawRect;
    dred_gui_draw_rect_outline_proc drawRectOutline;
    dred_gui_draw_text_proc         drawText;
};

struct dred_gui_image
{
    /// A pointer to the context that owns this image.
    dred_gui* pGUI;

    /// The resource handle that is passed around to the callback functions.
    dtk_surface* pInternalImage;
};

struct dred_gui_font
{
    /// A pointer to the context that owns this font.
    dred_gui* pGUI;

    /// The font family.
    char family[DRED_MAX_FONT_FAMILY_LENGTH];

    /// The base size of the font. This is set to the value that was used to create the font in the first place.
    unsigned int size;

    /// The font's weight.
    dtk_font_weight weight;

    /// The fon't slant.
    dtk_font_slant slant;

    /// The font's flags. Can be a combination of the following:
    ///   DRED_GUI_FONT_NO_CLEARTYPE
    unsigned int flags;

    /// The internal font. This is created by the rendering backend.
    dtk_font* pInternalFont;
};


struct dred_control
{
    // The base DTK control.
    dtk_control baseControl;

    /// A pointer to the context that owns this element. This should never be null for valid elements.
    dred_gui* pGUI;

    /// The type of the element, as a string. This is only every used by the host application, and is intended to be used as way
    /// to selectively perform certain operations on specific types of GUI elements.
    char type[64];

    /// The function to call when the element's relative position moves.
    dred_gui_on_move_proc onMove;

    /// The function to call when the element's size changes.
    dred_gui_on_size_proc onSize;

    /// The function to call when the mouse enters the given element.
    dred_gui_on_mouse_enter_proc onMouseEnter;

    /// The function to call when the mouse leaves the given element.
    dred_gui_on_mouse_leave_proc onMouseLeave;

    /// The function to call when the mouse is moved while over the element.
    dred_gui_on_mouse_move_proc onMouseMove;

    /// The function to call when a mouse buttonis pressed while over the element.
    dred_gui_on_mouse_button_down_proc onMouseButtonDown;

    /// The function to call when a mouse button is released while over the element.
    dred_gui_on_mouse_button_up_proc onMouseButtonUp;

    /// The function to call when a mouse button is double-clicked while over the element.
    dred_gui_on_mouse_button_dblclick_proc onMouseButtonDblClick;

    /// The function to call when the mouse wheel it turned while over the element.
    dred_gui_on_mouse_wheel_proc onMouseWheel;

    /// The function to call when a key on the keyboard is pressed or auto-repeated.
    dred_gui_on_key_down_proc onKeyDown;

    /// The function to call when a key on the keyboard is released.
    dred_gui_on_key_up_proc onKeyUp;

    /// The function to call when a printable character is pressed or auto-repeated. This would be used for text editing.
    dred_gui_on_printable_key_down_proc onPrintableKeyDown;

    /// The function to call when the paint event is received.
    dred_gui_on_paint_proc onPaint;

    /// The function to call when the element is marked as dirty.
    dred_gui_on_dirty_proc onDirty;

    /// The function to call when a hit test needs to be performed.
    dred_gui_on_hittest_proc onHitTest;

    /// The event handler to call when an element receives the mouse focus.
    dred_gui_on_capture_mouse_proc onCaptureMouse;

    /// The event handler to call when an element loses the mouse focus.
    dred_gui_on_release_mouse_proc onReleaseMouse;

    /// The event handler to call when an element receives the keyboard focus.
    dred_gui_on_capture_keyboard_proc onCaptureKeyboard;

    /// The event handler to call when an element loses the keyboard focus.
    dred_gui_on_release_keyboard_proc onReleaseKeyboard;
};

struct dred_gui
{
    // The dred context that owns the GUI system.
    dred_context* pDred;

    // The painting callbacks.
    dred_gui_painting_callbacks paintingCallbacks;
};



/////////////////////////////////////////////////////////////////
//
// CORE API
//
/////////////////////////////////////////////////////////////////

// Initializes a GUI context.
dtk_bool32 dred_gui_init(dred_gui* pGUI, dred_context* pDred);

/// Deletes a context and everything that it created.
void dred_gui_uninit(dred_gui* pGUI);



/////////////////////////////////////////////////////////////////
// Controls

// The default event handler for dred_control's.
dtk_bool32 dred_control_event_handler(dtk_event* pEvent);

/// Creates an element.
dtk_bool32 dred_control_init(dred_control* pControl, dred_context* pDred, dred_control* pParent, dtk_control* pDTKParent, const char* type, dtk_event_proc onEvent);

/// Deletes and element.
void dred_control_uninit(dred_control* pControl);


// Retrieves the dred context that owns the given control.
dred_context* dred_control_get_context(dred_control* pControl);


/// Sets the type of the element.
///
/// The type name cannot be more than 63 characters in length.
dtk_bool32 dred_control_set_type(dred_control* pControl, const char* type);

/// Retrieves the type fo the element.
const char* dred_control_get_type(dred_control* pControl);

/// Determines whether or not the given element is of the given type.
dtk_bool32 dred_control_is_of_type(dred_control* pControl, const char* type);
dtk_bool32 dred_is_control_type_of_type(const char* type, const char* base);


/// Hides the given element.
void dred_control_hide(dred_control *pControl);

/// Shows the given element.
void dred_control_show(dred_control* pControl);

/// Determines whether or not the element is marked as visible.
///
/// @remarks
///     This is a direct accessor for the internal visible flag of the element and is not recursive. Thus, if this element is
///     marked as visible, but it's parent is invisible, it will still return DTK_TRUE. Use dred_control_is_visible_recursive() to do
///     a recursive visibility check.
dtk_bool32 dred_control_is_visible(const dred_control* pControl);

/// Recursively determines whether or not the element is marked as visible.
dtk_bool32 dred_control_is_visible_recursive(const dred_control* pControl);


/// Disables clipping against the parent for the given element.
void dred_control_disable_clipping(dred_control* pControl);

/// Enables clipping against the parent for the given element.
void dred_control_enable_clipping(dred_control* pControl);

/// Determines whether or not clipping is enabled for the given element.
dtk_bool32 dred_control_is_clipping_enabled(const dred_control* pControl);


/// Sets the element that should receive all future mouse related events.
///
/// @remarks
///     Release the mouse capture with dred_gui_release_mouse().
void dred_gui_capture_mouse(dred_control* pControl);
void dred_control_capture_mouse(dred_control* pControl) { dred_gui_capture_mouse(pControl); }

/// Releases the mouse capture.
void dred_gui_release_mouse(dred_gui* pGUI);

/// Sets the element that should receive all future keyboard related events.
///
/// @remarks
///     Releases the keyboard capture with dred_gui_release_keyboard().
void dred_gui_capture_keyboard(dred_control* pControl);
void dred_control_capture_keyboard(dred_control* pControl) { dred_gui_capture_keyboard(pControl); }

/// Releases the keyboard capture.
void dred_gui_release_keyboard(dred_gui* pGUI);

/// Sets the cursor to use when the mouse enters the given GUI element.
void dred_control_set_cursor(dred_control* pControl, dtk_system_cursor_type cursor);

/// Retrieves the cursor to use when the mouse enters the given GUI element.
dtk_system_cursor_type dred_control_get_cursor(dred_control* pControl);

// Helper function for showing a popup menu relative to the given control.
void dred_control_show_popup_menu(dred_control* pControl, dtk_menu* pMenu, int relativePosX, int relativePosY);


//// Events ////

/// Registers the on_move event callback.
void dred_control_set_on_move(dred_control* pControl, dred_gui_on_move_proc callback);

/// Registers the on_size event callback.
void dred_control_set_on_size(dred_control* pControl, dred_gui_on_size_proc callback);

/// Registers the on_mouse_enter event callback.
void dred_control_set_on_mouse_enter(dred_control* pControl, dred_gui_on_mouse_enter_proc callback);

/// Registers the on_mouse_leave event callback.
void dred_control_set_on_mouse_leave(dred_control* pControl, dred_gui_on_mouse_leave_proc callback);

/// Registers the on_mouse_move event callback.
void dred_control_set_on_mouse_move(dred_control* pControl, dred_gui_on_mouse_move_proc callback);

/// Registers the on_mouse_button_down event callback.
void dred_control_set_on_mouse_button_down(dred_control* pControl, dred_gui_on_mouse_button_down_proc callback);

/// Registers the on_mouse_button_up event callback.
void dred_control_set_on_mouse_button_up(dred_control* pControl, dred_gui_on_mouse_button_up_proc callback);

/// Registers the on_mouse_button_down event callback.
void dred_control_set_on_mouse_button_dblclick(dred_control* pControl, dred_gui_on_mouse_button_dblclick_proc callback);

/// Registers the on_mouse_wheel event callback.
void dred_control_set_on_mouse_wheel(dred_control* pControl, dred_gui_on_mouse_wheel_proc callback);

/// Registers the on_key_down event callback.
void dred_control_set_on_key_down(dred_control* pControl, dred_gui_on_key_down_proc callback);

/// Registers the on_key_up event callback.
void dred_control_set_on_key_up(dred_control* pControl, dred_gui_on_key_up_proc callback);

/// Registers the on_printable_key_down event callback.
void dred_control_set_on_printable_key_down(dred_control* pControl, dred_gui_on_printable_key_down_proc callback);

/// Registers the on_paint event callback.
void dred_control_set_on_paint(dred_control* pControl, dred_gui_on_paint_proc callback);

/// Registers the on_dirty event callback.
void dred_control_set_on_dirty(dred_control* pControl, dred_gui_on_dirty_proc callback);

/// Registers the on_hittest event callback.
void dred_control_set_on_hittest(dred_control* pControl, dred_gui_on_hittest_proc callback);

/// Registers the on_capture_mouse event callback.
void dred_control_set_on_capture_mouse(dred_control* pControl, dred_gui_on_capture_mouse_proc callback);

/// Registers the on_release_mouse event callback.
void dred_control_set_on_release_mouse(dred_control* pControl, dred_gui_on_release_mouse_proc callback);

/// Registers the on_capture_keyboard event callback.
void dred_control_set_on_capture_keyboard(dred_control* pControl, dred_gui_on_capture_keyboard_proc callback);

/// Registers the on_release_keyboard event callback.
void dred_control_set_on_release_keyboard(dred_control* pControl, dred_gui_on_release_keyboard_proc callback);



//// Containment and Hit Detection ////

/// Determines whether or not the given point is inside the bounds of the given element.
///
/// @remarks
///     This only checks if the point is inside the bounds of the element and does not take hit testing into account. This difference
///     with this one and dred_control_is_point_inside() is that the latter will use hit testing.
dtk_bool32 dred_control_is_point_inside_bounds(const dred_control* pControl, float absolutePosX, float absolutePosY);

/// Determines whether or not the given point is inside the given element.
///
/// @remarks
///     This will use hit testing to determine whether or not the point is inside the element.
dtk_bool32 dred_control_is_point_inside(dred_control* pControl, float absolutePosX, float absolutePosY);

/// Finds the element under the given point taking mouse pass-through and hit testing into account.
//dtk_control* dred_gui_find_control_under_point(dred_control* pTopLevelControl, float absolutePosX, float absolutePosY);

/// Determines whether or not the given element is currently sitting directly under the mouse.
dtk_bool32 dred_control_is_under_mouse(dred_control* pTopLevelControl);



//// Hierarchy ////

/// Detaches the given element from it's parent.
void dred_control_detach(dred_control* pChildControl);

/// Attaches the given element as a child of the given parent element, and appends it to the end of the children list.
void dred_control_append(dred_control* pChildControl, dred_control* pParentControl);

/// Attaches the given element as a child of the given parent element, and prepends it to the end of the children list.
void dred_control_prepend(dred_control* pChildControl, dred_control* pParentControl);

/// Appends the given element to the given sibling.
void dred_control_append_sibling(dred_control* pControlToAppend, dred_control* pControlToAppendTo);

/// Prepends the given element to the given sibling.
void dred_control_prepend_sibling(dred_control* pControlToPrepend, dred_control* pControlToPrependTo);

/// Retrieves a pointer to the given element's top-level ancestor.
///
/// @remarks
///     If pControl is the top level element, the return value will be pControl.
dtk_control* dred_control_find_top_level_control(dred_control* pControl);

/// Determines whether or not the given element is the parent of the other.
///
/// @remarks
///     This is not recursive. Use dred_control_is_ancestor() to do a recursive traversal.
dtk_bool32 dred_control_is_parent(dred_control* pParentControl, dred_control* pChildControl);

/// Determines whether or not the given element is a child of the other.
///
/// @remarks
///     This is not recursive. Use dred_control_is_descendant() to do a recursive traversal.
dtk_bool32 dred_control_is_child(dred_control* pChildControl, dred_control* pParentControl);

/// Determines whether or not the given element is an ancestor of the other.
dtk_bool32 dred_control_is_ancestor(dred_control* pAncestorControl, dred_control* pChildControl);

/// Determines whether or not the given element is a descendant of the other.
dtk_bool32 dred_control_is_descendant(dred_control* pChildControl, dred_control* pAncestorControl);

/// Determines whether or not the given element is itself or a descendant.
dtk_bool32 dred_control_is_self_or_ancestor(dred_control* pAncestorControl, dred_control* pChildControl);

/// Determines whether or not the given element is itself or a descendant.
dtk_bool32 dred_control_is_self_or_descendant(dred_control* pChildControl, dred_control* pAncestorControl);



//// Layout ////

/// Sets the absolute position of the given element.
void dred_control_set_absolute_position(dred_control* pControl, float positionX, float positionY);

/// Retrieves the absolute position of the given element.
void dred_control_get_absolute_position(const dred_control* pControl, float* positionXOut, float* positionYOut);
float dred_control_get_absolute_position_x(const dred_control* pControl);
float dred_control_get_absolute_position_y(const dred_control* pControl);


/// Sets the relative position of the given element.
void dred_control_set_relative_position(dred_control* pControl, float relativePosX, float relativePosY);

/// Retrieves the relative position of the given element.
void dred_control_get_relative_position(const dred_control* pControl, float* relativePosXOut, float* relativePosYOut);
float dred_control_get_relative_position_x(const dred_control* pControl);
float dred_control_get_relative_position_y(const dred_control* pControl);


/// Sets the size of the given element.
void dred_control_set_size(dred_control* pControl, float width, float height);

/// Retrieves the size of the given element.
void dred_control_get_size(const dred_control* pControl, float* widthOut, float* heightOut);
float dred_control_get_width(const dred_control* pControl);
float dred_control_get_height(const dred_control* pControl);



/// Retrieves the absolute rectangle for the given element.
dred_rect dred_control_get_absolute_rect(const dred_control* pControl);

/// Retrieves the relative rectangle for the given element.
dred_rect dred_control_get_relative_rect(const dred_control* pControl);

/// Retrieves the local rectangle for the given element.
///
/// @remarks
///     The local rectangle is equivalent to dred_make_rect(0, 0, dred_control_get_width(pControl), dred_control_get_height(pControl));
dred_rect dred_control_get_local_rect(const dred_control* pControl);



//// Painting ////

/// Registers the custom painting callbacks.
///
/// @remarks
///     This can only be called once, so it should always be done after initialization. This will fail if called
///     more than once.
dtk_bool32 dred_gui_register_painting_callbacks(dred_gui* pGUI, dred_gui_painting_callbacks callbacks);

/// Draws a rectangle on the given element.
void dred_control_draw_rect(dred_control* pControl, dred_rect relativeRect, dtk_color color, dtk_surface* pSurface);



/////////////////////////////////////////////////////////////////
//
// HIGH-LEVEL API
//
/////////////////////////////////////////////////////////////////

//// Hit Testing and Layout ////

/// An on_size event callback that resizes every child element to that of the parent.
void dred_control_on_size_fit_children_to_parent(dred_control* pControl, float newWidth, float newHeight);

/// An on_hit_test event callback that can be used to always fail the mouse hit test.
dtk_bool32 dred_control_pass_through_hit_test(dred_control* pControl, float mousePosX, float mousePosY);


//// Painting ////

/// Draws a border around the given element.
void dred_control_draw_border(dred_control* pControl, float borderWidth, dtk_color color, dtk_surface* pSurface);



/////////////////////////////////////////////////////////////////
//
// UTILITY API
//
/////////////////////////////////////////////////////////////////

/// Clamps the given rectangle to another.
dred_rect dred_clamp_rect(dred_rect rect, dred_rect other);

/// Clamps the given rectangle to the given element and returns whether or not any of it is contained within the element's rectangle.
dtk_bool32 dred_clamp_rect_to_element(const dred_control* pControl, dred_rect* pRelativeRect);

/// Converts the given rectangle from absolute to relative to the given element.
dred_rect dred_make_rect_relative(const dred_control* pControl, dred_rect* pRect);

/// Converts the given rectangle from relative to absolute based on the given element.
dred_rect dred_make_rect_absolute(const dred_control* pControl, dred_rect* pRect);

/// Converts the given point from absolute to relative to the given element.
void dred_make_point_relative(const dred_control* pControl, float* positionX, float* positionY);

/// Converts the given point from relative to absolute based on the given element.
void dred_make_point_absolute(const dred_control* pControl, float* positionX, float* positionY);

/// Creates a dred_rect object.
dred_rect dred_make_rect(float left, float top, float right, float bottom);

/// Creates an inside-out rectangle.
///
/// @remarks
///     An inside our rectangle is a negative-dimension rectangle with each edge at the extreme edges. The left edge will be at the
///     right-most side and the right edge will be at the left-most side. The same applies for the top and bottom edges.
dred_rect dred_make_inside_out_rect();

/// Expands the given rectangle on all sides by the given amount.
///
/// @remarks
///     This will increase the width and height of the rectangle by <amount> x 2.
///     @par
///     The growth amount can be negative, in which case it will be shrunk. Note that this does not do any checking to ensure the rectangle
///     contains positive dimensions after a shrink.
dred_rect dred_grow_rect(dred_rect rect, float amount);

/// Scales the given rectangle.
///
/// @param scaleX [in] The scale to apply to <left> and <right>
/// @param scaleY [in] The scale to apply to <top> and <bottom>
///
/// @remarks
///     This will modify the <left> and <top> properties which means the rectangle will change position. To adjust only the size, scale the
///     rectangle manually.
dred_rect dred_scale_rect(dred_rect rect, float scaleX, float scaleY);

/// Offsets the given rectangle.
dred_rect dred_offset_rect(dred_rect rect, float offsetX, float offsetY);

/// Creates a rectangle that contains both of the given rectangles.
dred_rect dred_rect_union(dred_rect rect0, dred_rect rect1);

/// Determines whether or not the given rectangle contains the given point.
///
/// @remarks
///     An important not here is that if the position is sitting on the right or bottom border, DTK_FALSE will be returned. If, however, the point
///     is sitting on the left or top border, DTK_TRUE will be returned. The reason for this is that elements may sit exactly side-by-side with
///     each other, and if we use this function to determine if a point is contained within an element (which we do), we would end up having
///     this return DTK_TRUE for both elements, which we don't want.
dtk_bool32 dred_rect_contains_point(dred_rect rect, float posX, float posY);

/// Determines whether or not two rectangles are equal.
dtk_bool32 dred_rect_equal(dred_rect rect0, dred_rect rect1);

/// Determines whether or not the given rectangle has any volume (width and height > 0).
dtk_bool32 dred_rect_has_volume(dred_rect rect);



/////////////////////////////////////////////////////////////////
//
// DTK Interop.
//
/////////////////////////////////////////////////////////////////

// A covenience function for creating a new context and registering the DTK painting callbacks.
//
// @remarks
//     This is equivalent to dred_gui_init() followed by dred_gui_register_dtk_callbacks().
dtk_bool32 dred_gui_init_dtk(dred_gui* pGUI, dred_context* pDred);

// Registers the drawing callbacks for use with DTK.
//
// @remarks
//     The user data of each callback is assumed to be a pointer to a dtk_surface object.
void dred_gui_register_dtk_callbacks(dred_gui* pGUI);

