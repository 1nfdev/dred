
bool dred_config_init(dred_config* pConfig, dred_context* pDred)
{
    if (pConfig == NULL || pDred == NULL) {
        return false;
    }

    pConfig->pDred = pDred;
    pConfig->pSystemFontUI = dred_parse_and_load_font(pDred, "system-font-ui");
    pConfig->pSystemFontMono = dred_parse_and_load_font(pDred, "system-font-mono");
    pConfig->pImageCross = dred_image_library_get_image_by_id(&pDred->imageLibrary, DRED_STOCK_IMAGE_ID_CROSS);

    dred_config_init_variables__autogenerated(pConfig);
    return true;
}

void dred_config_uninit(dred_config* pConfig)
{
    if (pConfig == NULL) {
        return;
    }

    for (size_t i = 0; i < pConfig->recentFileCount; ++i) {
        gb_free_string(pConfig->recentFiles[i]);
    }

    dred_config_uninit_variables__autogenerated(pConfig);
}


typedef struct
{
    dred_config* pConfig;
    const char* filePath;
    dred_config_on_error_proc onError;
    void* pUserData;
    dred_file file;
} dred_config_load_file__data;

size_t dred_config_load_file__on_read(void* pUserData, void* pDataOut, size_t bytesToRead)
{
    dred_config_load_file__data* pData = (dred_config_load_file__data*)pUserData;
    assert(pData != NULL);
    assert(pData->file != NULL);

    size_t bytesRead;
    if (!dred_file_read(pData->file, pDataOut, bytesToRead, &bytesRead)) {
        return 0;
    }

    return bytesRead;
}

void dred_config_load_file__on_pair(void* pUserData, const char* key, const char* value)
{
    dred_config_load_file__data* pData = (dred_config_load_file__data*)pUserData;
    assert(pData != NULL);

    if (strcmp(key, "include") == 0) {
        char fileAbsolutePath[DRED_MAX_PATH];
        if (!dred_to_absolute_path(pData->filePath, fileAbsolutePath, sizeof(fileAbsolutePath))) {
            return;
        }
        if (!drpath_remove_file_name(fileAbsolutePath)) {
            return;
        }

        char includeRelativePath[DRED_MAX_PATH];
        if (dr_next_token(value, includeRelativePath, sizeof(includeRelativePath)) == NULL) {
            return;
        }

        char includeAbsolutePath[DRED_MAX_PATH];
        if (drpath_append_and_clean(includeAbsolutePath, sizeof(includeAbsolutePath), fileAbsolutePath, includeRelativePath) == 0) {
            return;
        }

        dred_load_config(pData->pConfig->pDred, includeAbsolutePath);
        return;
    }

    if (strcmp(key, "exec") == 0) {
        dred_exec(pData->pConfig->pDred, dr_first_non_whitespace(value));
        return;
    }

    if (strcmp(key, "bind") == 0) {
        char shortcutName[256];
        dred_shortcut shortcut;
        const char* commandStr;
        if (dred_parse_bind_command(value, shortcutName, sizeof(shortcutName), &shortcut, &commandStr)) {
            dred_bind_shortcut(pData->pConfig->pDred, shortcutName, shortcut, commandStr);
        }

        return;
    }

    if (strcmp(key, "recent-file") == 0) {
        char filePath[DRED_MAX_PATH];
        if (dr_next_token(value, filePath, sizeof(filePath)) != NULL) {
            if (dr_file_exists(filePath)) {
                dred_config_push_recent_file(pData->pConfig, filePath);
            }
        }

        return;
    }


    dred_config_set__autogenerated(pData->pConfig, key, value);
}

void dred_config_load_file__on_error(void* pUserData, const char* message, unsigned int line)
{
    dred_config_load_file__data* pData = (dred_config_load_file__data*)pUserData;
    assert(pData != NULL);

    if (pData->onError) {
        pData->onError(pData->pConfig, pData->filePath, message, line, pData->pUserData);
    }
}

bool dred_config_load_file(dred_config* pConfig, const char* filePath, dred_config_on_error_proc onError, void* pUserData)
{
    if (pConfig == NULL) {
        return false;
    }

    dred_file file = dred_file_open(filePath, DRED_FILE_OPEN_MODE_READ);
    if (file == NULL) {
        return false;
    }

    dred_config_load_file__data data;
    data.pConfig = pConfig;
    data.filePath = filePath;
    data.onError = onError;
    data.pUserData = pUserData;
    data.file = file;
    dr_parse_key_value_pairs(dred_config_load_file__on_read, dred_config_load_file__on_pair, dred_config_load_file__on_error, &data);

    dred_file_close(file);
    return true;
}

void dred_config_set(dred_config* pConfig, const char* name, const char* value)
{
    if (pConfig == NULL) {
        return;
    }

    dred_config_set__autogenerated(pConfig, name, value);
}

void dred_config_push_recent_file(dred_config* pConfig, const char* fileAbsolutePath)
{
    if (pConfig == NULL) {
        return;
    }

    // If the path already exists, just move it to the end.
    for (size_t i = 0; i < pConfig->recentFileCount; ++i) {
        if (drpath_equal(fileAbsolutePath, pConfig->recentFiles[i])) {
            char* existingPath = pConfig->recentFiles[i];
            for (size_t j = i; j > 0; --j) {
                pConfig->recentFiles[j] = pConfig->recentFiles[j-1];
            }

            pConfig->recentFiles[0] = existingPath;
            return;
        }
    }


    // We need to drop the oldest file if we've run out of room.
    if (pConfig->recentFileCount == DRED_MAX_RECENT_FILES) {
        gb_free_string(pConfig->recentFiles[pConfig->recentFileCount-1]);
        pConfig->recentFileCount -= 1;
    }

    assert(pConfig->recentFileCount < DRED_MAX_RECENT_FILES);

    // The most recent file is at position 0. Existing items need to be moved up a slot.
    for (size_t i = pConfig->recentFileCount; i > 0; --i) {
        pConfig->recentFiles[i] = pConfig->recentFiles[i-1];
    }

    // The path needs to be cleaned for aesthetic just to make it look nicer in the Recent Files menu.
    char filePathClean[DRED_MAX_PATH];
    drpath_clean(fileAbsolutePath, filePathClean, sizeof(filePathClean));

    pConfig->recentFiles[0] = gb_make_string(filePathClean);
    pConfig->recentFileCount += 1;
}



// Set handlers.

void dred_config_on_set__show_tab_bar(dred_context* pDred)
{
    if (pDred->config.showTabBar) {
        dred_show_tabbars(pDred);
    } else {
        dred_hide_tabbars(pDred);
    }
}

void dred_config_on_set__show_menu_bar(dred_context* pDred)
{
    if (pDred->config.showMenuBar) {
        dred_show_menu_bar(pDred);
    } else {
        dred_hide_menu_bar(pDred);
    }
}

void dred_config_on_set__auto_hide_cmd_bar(dred_context* pDred)
{
    if (pDred->config.autoHideCmdBar) {
        dred_enable_auto_hide_command_bar(pDred);
    } else {
        dred_disable_auto_hide_command_bar(pDred);
    }
}


void dred_config_on_set__cmdbar_bg_color(dred_context* pDred)
{
    dred_cmdbar_refresh_styling(pDred->pCmdBar);
}

void dred_config_on_set__cmdbar_bg_color_active(dred_context* pDred)
{
    dred_cmdbar_refresh_styling(pDred->pCmdBar);
}


void dred_config_on_set__ui_font(dred_context* pDred)
{
    // Everything that uses the UI font needs to be updated.
    dred_cmdbar_refresh_styling(pDred->pCmdBar);

    // The UI font may have resulted in the main window's layout becoming invalid.
    dred_update_main_window_layout(pDred);
}

void dred_config_on_set__texteditor_font(dred_context* pDred)
{
    // The font's of every text editor need to be updated.
    for (dred_tabgroup* pTabGroup = dred_first_tabgroup(pDred); pTabGroup != NULL; pTabGroup = dred_tabgroup_next_tabgroup(pTabGroup)) {
        for (dred_tab* pTab = dred_tabgroup_first_tab(pTabGroup); pTab != NULL; pTab = dred_tabgroup_next_tab(pTabGroup, pTab)) {
            dred_control* pControl = dred_tab_get_control(pTab);
            if (dred_control_is_of_type(pControl, DRED_CONTROL_TYPE_TEXT_EDITOR)) {
                dred_text_editor_set_font(pControl, pDred->config.pTextEditorFont);
            }
        }
    }
}
