
bool dred_config_init(dred_config* pConfig, dred_context* pDred)
{
    if (pConfig == NULL || pDred == NULL) {
        return false;
    }

    pConfig->pDred = pDred;
    pConfig->pImageCross = dred_image_library_get_image_by_id(&pDred->imageLibrary, DRED_STOCK_IMAGE_ID_CROSS);

    dred_config_init_variables__autogenerated(pConfig);
    return true;
}

void dred_config_uninit(dred_config* pConfig)
{
    if (pConfig == NULL) {
        return;
    }

    dred_config_uninit_variables__autogenerated(pConfig);
}


typedef struct
{
    dred_config* pConfig;
    const char* filePath;
    dred_config_on_error_proc onError;
    void* pUserData;
    dred_file file;
} dred_config_load_file__data;

size_t dred_config_load_file__on_read(void* pUserData, void* pDataOut, size_t bytesToRead)
{
    dred_config_load_file__data* pData = (dred_config_load_file__data*)pUserData;
    assert(pData != NULL);
    assert(pData->file != NULL);

    size_t bytesRead;
    if (!dred_file_read(pData->file, pDataOut, bytesToRead, &bytesRead)) {
        return 0;
    }

    return bytesRead;
}

void dred_config_load_file__on_pair(void* pUserData, const char* key, const char* value)
{
    dred_config_load_file__data* pData = (dred_config_load_file__data*)pUserData;
    assert(pData != NULL);

    if (strcmp(key, "include") == 0) {
        char fileAbsolutePath[DRED_MAX_PATH];
        if (!dred_to_absolute_path(pData->filePath, fileAbsolutePath, sizeof(fileAbsolutePath))) {
            return;
        }
        if (!drpath_remove_file_name(fileAbsolutePath)) {
            return;
        }

        char includeRelativePath[DRED_MAX_PATH];
        if (dr_next_token(value, includeRelativePath, sizeof(includeRelativePath)) == NULL) {
            return;
        }

        char includeAbsolutePath[DRED_MAX_PATH];
        if (drpath_append_and_clean(includeAbsolutePath, sizeof(includeAbsolutePath), fileAbsolutePath, includeRelativePath) == 0) {
            return;
        }

        dred_load_config(pData->pConfig->pDred, includeAbsolutePath);
        return;
    }

    if (strcmp(key, "exec") == 0) {
        dred_exec(pData->pConfig->pDred, dr_first_non_whitespace(value));
        return;
    }

    if (strcmp(key, "bind") == 0) {
        char shortcutName[256];
        dred_shortcut shortcut;
        const char* commandStr;
        if (dred_parse_bind_command(value, shortcutName, sizeof(shortcutName), &shortcut, &commandStr)) {
            dred_bind_shortcut(pData->pConfig->pDred, shortcutName, shortcut, commandStr);
        }

        return;
    }


    dred_config_parse_variable__autogenerated(pData->pConfig, key, value);
}

void dred_config_load_file__on_error(void* pUserData, const char* message, unsigned int line)
{
    dred_config_load_file__data* pData = (dred_config_load_file__data*)pUserData;
    assert(pData != NULL);

    if (pData->onError) {
        pData->onError(pData->pConfig, pData->filePath, message, line, pData->pUserData);
    }
}

bool dred_config_load_file(dred_config* pConfig, const char* filePath, dred_config_on_error_proc onError, void* pUserData)
{
    if (pConfig == NULL) {
        return false;
    }

    dred_file file = dred_file_open(filePath, DRED_FILE_OPEN_MODE_READ);
    if (file == NULL) {
        return false;
    }

    dred_config_load_file__data data;
    data.pConfig = pConfig;
    data.filePath = filePath;
    data.onError = onError;
    data.pUserData = pUserData;
    data.file = file;
    dr_parse_key_value_pairs(dred_config_load_file__on_read, dred_config_load_file__on_pair, dred_config_load_file__on_error, &data);

    dred_file_close(file);
    return true;
}
